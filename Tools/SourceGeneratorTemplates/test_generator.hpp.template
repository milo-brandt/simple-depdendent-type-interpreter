/*
  This file contains automatically generated tests.
*/

#include <catch.hpp>
#include <sstream>
#include "../Top/run_source.hpp"
#include "../NewExpression/arena_utility.hpp"

{%- macro test_case(test) %}
{%- if test.preamble %}
{%- call in_namespace(test.preamble.namespace) %}
{{ test.preamble.body }}
{%- endcall %}
{%- endif %}
TEST_CASE("{{ test.name }}", "[full_case]{% if test.tags %}{% for tag in test.tags %}[{{tag}}]{% endfor %}{% endif %}") {
  INFO("Test case from file: {{ test.filename }}");
  new_expression::Arena arena;
  {
    pipeline::compile::StandardCompilerContext context(arena);
    new_expression::SimpleEvaluationContext reduction_context{arena, context.context.rule_collector};
    {%- for definition in test.definitions %}
    {%- if definition.kind == "SET" %}
    auto {{definition.var}}_full = run_source(arena, context, R"#--#({{ definition.source }})#--#");
    if({{definition.var}}_full.holds_error()) {
      INFO({{definition.var}}_full.get_error());
      FAIL("Failed while compiling variable {{definition.var}}");
    }
    if(!{{definition.var}}_full.get_value().first.is_okay()) {
      std::stringstream error_message;
      {{definition.var}}_full.get_value().first.report_errors_to(error_message, {arena});
      INFO(error_message.str())
      FAIL("Failed while compiling variable {{definition.var}}");
    }
    new_expression::TypedValue {{definition.var}} {
      .value = reduction_context.reduce(arena.copy({{definition.var}}_full.get_value().first.result.value)),
      .type = reduction_context.reduce(arena.copy({{definition.var}}_full.get_value().first.result.type))
    };
    destroy_from_arena(arena, {{definition.var}}_full.get_value());
    {%- elif definition.kind == "FULL_SET" %}
    auto {{definition.var}} = map(
      run_source(arena, context, R"#--#({{ definition.source }})#--#"),
      [&](std::pair<pipeline::compile::EvaluateInfo, ModuleLoadInfo>&& result) {
        destroy_from_arena(arena, result.second);
        return std::move(result.first);
      }
    );
    {%- elif definition.kind == "MUST_COMPILE" %}
    {
      auto must_compile_result = run_source(arena, context, R"#--#({{ definition.source }})#--#");
      if(must_compile_result.holds_error()) {
        INFO(must_compile_result.get_error());
        FAIL("Failed while compiling MUST_COMPILE case.");
      }
      if(!must_compile_result.get_value().first.is_okay()) {
        std::stringstream error_message;
        must_compile_result.get_value().first.report_errors_to(error_message, {arena});
        INFO(error_message.str())
        FAIL("Failed while compiling MUST_COMPILE case.");
      }
      destroy_from_arena(arena, must_compile_result.get_value());
    }
    {%- else %}
    static_assert(false, "The source code generator did something wrong.")
    {%- endif %}
    {%- endfor %}
    {%- if test.body %}
    {{ test.body }}
    {%- endif %}
    {%- for definition in test.definitions %}
    {%- if definition.kind == "SET" %}
    destroy_from_arena(arena, {{definition.var}});
    {%- elif definition.kind == "FULL_SET" %}
    if({{definition.var}}.holds_success()) {
      destroy_from_arena(arena, {{definition.var}}.get_value());
    }
    {%- elif definition.kind == "MUST_COMPILE" %}
    {# Nothing to do in this case. Value was already discarded. #}
    {%- else %}
    static_assert(false, "The source code generator did something wrong.")
    {%- endif %}
    {%- endfor %}
  }
  arena.clear_orphaned_expressions();
  REQUIRE(arena.empty());
}
{%- endmacro %}

{%- for test in tests %}
{{ test_case(test) }}
{%- endfor %}
