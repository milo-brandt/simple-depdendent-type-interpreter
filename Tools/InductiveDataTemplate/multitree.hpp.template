{%if base_namespace %}
namespace {{base_namespace}} {
{%- endif %}
{%- for component in components %}
  struct {{component.name}};
{%- endfor %}

	struct {{class_name}} {
    {%- for tree in trees %}
    {{tree.type}} {{tree.member}};
    {%- endfor %}
		{%- for component in components %}
		{{class_name}}({{component.name}} arg);
		{%- endfor %}
	};
{%- for component in components %}
	struct {{component.name}} {
{%- for member in component.base_members %}
		{{member.type}} {{member.name}};
{%- endfor %}
{%- for tree in trees %}
{%- for member in component.extra_members[tree.type] %}
    {{member.type}} {{member.name}};
{%- endfor %}
{%- endfor %}
	};
{%- endfor %}
{% for component in components %}
  inline {{class_name}}::{{class_name}}({{component.name}} arg):
  {%- for tree in trees %}
    {{ tree.member }}([&]() -> {{tree.type}} {
      return {{tree.namespace}}{{component.name}}{
        {%- for member in component.base_members %}
        {%- if member.kind == "Self" %}
        .{{member.name}} = std::move(arg.{{member.name}}.{{tree.member}})
        {%- elif member.kind == "OptionalSelf" %}
        .{{member.name}} = [&]() -> std::optional<{{tree.type}}> {
          if(arg.{{member.name}}) {
            return std::move(arg.{{member.name}}->{{tree.member}});
          } else {
            return std::nullopt;
          }
        }()
        {%- else %}
        static_assert(false, "Invalid base kind")
        {%- endif %}{% if not loop.last %},{% endif %}
        {%- endfor %}
        {%- for member in component.extra_members[tree.type] %}{% if loop.first %}{% if component.base_members is nonempty %},{% endif %}{% else %},{% endif %}
        .{{member.name}} = std::move(arg.{{member.name}})
        {%- endfor %}
      };
    }()){% if not loop.last %},{% endif %}
  {%- endfor %}
  {%- for tree in trees %}
  {%- endfor %}
  {}
{%- endfor %}
{%- if base_namespace %}
}
{% endif %}
