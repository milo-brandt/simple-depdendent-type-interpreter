/*
This file is automatically generated! Please do not make edits to it as they will be overwritten in the build process. Edits should instead be made to...
...the specification for this file: 
...the script which generates these files: 
*/

#include "../Utility/indirect.hpp"
#include "../Utility/overloaded.hpp"
#include <variant>
#include <type_traits>
#include <vector>
#include <optional>
#include <cstdint>
#include <iostream>
#include <string>
#include "resolved_tree_explanation.hpp"

namespace compiler::resolution::path {
  struct Path {
    std::vector<std::uint64_t> steps;
  };
  inline bool operator==(Path const& lhs, Path const& rhs) { return lhs.steps == rhs.steps; }
}



namespace compiler::resolution::output {

	struct Apply;
	struct Lambda;
	struct Local;
	struct Hole;
	struct Embed;

	class Tree {
		struct Impl;
		mdb::Indirect<Impl> data;
	public:
		Tree(Apply arg);
		Tree(Lambda arg);
		Tree(Local arg);
		Tree(Hole arg);
		Tree(Embed arg);
		
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		
		Lambda& get_lambda() &;
		Lambda const& get_lambda() const&;
		Lambda&& get_lambda() &&;
		Lambda* get_if_lambda();
		Lambda const* get_if_lambda() const;
		
		Local& get_local() &;
		Local const& get_local() const&;
		Local&& get_local() &&;
		Local* get_if_local();
		Local const* get_if_local() const;
		
		Hole& get_hole() &;
		Hole const& get_hole() const&;
		Hole&& get_hole() &&;
		Hole* get_if_hole();
		Hole const* get_if_hole() const;
		
		Embed& get_embed() &;
		Embed const& get_embed() const&;
		Embed&& get_embed() &&;
		Embed* get_if_embed();
		Embed const* get_if_embed() const;
		
		template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Local& local, Hole& hole, Embed& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Local&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Embed&> >;
})
		decltype(auto) visit(Visitor&&) &;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Local const& local, Hole const& hole, Embed const& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local const&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed const&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Local const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Embed const&> >;
})
		decltype(auto) visit(Visitor&&) const&;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Local&& local, Hole&& hole, Embed&& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Local&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Embed&&> >;
})
		decltype(auto) visit(Visitor&&) &&;

	};
	struct Apply {
		Tree lhs;
		Tree rhs;
	};
	struct Lambda {
		Tree body;
		Tree type;
	};
	struct Local {
		std::uint64_t stack_index;
	};
	struct Hole {
	};
	struct Embed {
		std::uint64_t embed_index;
	};
	

	struct Tree::Impl {
		std::variant<Apply, Lambda, Local, Hole, Embed> data;
	};
	
	inline Tree::Tree(Apply arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Lambda arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Local arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Hole arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Embed arg):data(mdb::in_place, std::move(arg)) {}
	
	inline Apply& Tree::get_apply() & { return std::get<Apply>(data->data); }
	inline Apply const& Tree::get_apply() const& { return std::get<Apply>(data->data); }
	inline Apply&& Tree::get_apply() && { return std::move(std::get<Apply>(data->data)); }
	inline Apply* Tree::get_if_apply() { return std::get_if<Apply>(&data->data); }
	inline Apply const* Tree::get_if_apply() const { return std::get_if<Apply>(&data->data); }
	
	inline Lambda& Tree::get_lambda() & { return std::get<Lambda>(data->data); }
	inline Lambda const& Tree::get_lambda() const& { return std::get<Lambda>(data->data); }
	inline Lambda&& Tree::get_lambda() && { return std::move(std::get<Lambda>(data->data)); }
	inline Lambda* Tree::get_if_lambda() { return std::get_if<Lambda>(&data->data); }
	inline Lambda const* Tree::get_if_lambda() const { return std::get_if<Lambda>(&data->data); }
	
	inline Local& Tree::get_local() & { return std::get<Local>(data->data); }
	inline Local const& Tree::get_local() const& { return std::get<Local>(data->data); }
	inline Local&& Tree::get_local() && { return std::move(std::get<Local>(data->data)); }
	inline Local* Tree::get_if_local() { return std::get_if<Local>(&data->data); }
	inline Local const* Tree::get_if_local() const { return std::get_if<Local>(&data->data); }
	
	inline Hole& Tree::get_hole() & { return std::get<Hole>(data->data); }
	inline Hole const& Tree::get_hole() const& { return std::get<Hole>(data->data); }
	inline Hole&& Tree::get_hole() && { return std::move(std::get<Hole>(data->data)); }
	inline Hole* Tree::get_if_hole() { return std::get_if<Hole>(&data->data); }
	inline Hole const* Tree::get_if_hole() const { return std::get_if<Hole>(&data->data); }
	
	inline Embed& Tree::get_embed() & { return std::get<Embed>(data->data); }
	inline Embed const& Tree::get_embed() const& { return std::get<Embed>(data->data); }
	inline Embed&& Tree::get_embed() && { return std::move(std::get<Embed>(data->data)); }
	inline Embed* Tree::get_if_embed() { return std::get_if<Embed>(&data->data); }
	inline Embed const* Tree::get_if_embed() const { return std::get_if<Embed>(&data->data); }
	

	template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Local& local, Hole& hole, Embed& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Local&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Embed&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) & {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Local const& local, Hole const& hole, Embed const& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local const&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed const&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Local const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Embed const&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) const& {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Local&& local, Hole&& hole, Embed&& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Local&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Embed&&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) && {
		return std::visit(std::forward<Visitor>(visitor), std::move(data->data));
	}


inline std::uint64_t path_segment_of(Tree Apply::* member) {
  if(member == &Apply::lhs) return 0;
  if(member == &Apply::rhs) return 1;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(Tree Lambda::* member) {
  if(member == &Lambda::body) return 0;
  if(member == &Lambda::type) return 1;
  std::terminate(); //unreachable
}
template<class... Ts>
inline void path_append(compiler::resolution::path::Path& path, Ts&&... ts) {
  (path.steps.push_back(path_segment_of(ts)) , ...);
}
template<class... Ts>
inline compiler::resolution::path::Path path_of(Ts&&... ts) {
  compiler::resolution::path::Path ret;
  path_append(ret, std::forward<Ts>(ts)...);
  return ret;
}

  
  inline Tree& path_step(Tree& in, std::uint64_t step) {
    return in.visit([&]<class T>(T& part) -> Tree& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Local>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Embed>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }
  
  
  inline Tree const& path_step(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T const& part) -> Tree const& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Local>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Embed>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }
  
  
    inline Tree& path_lookup(Tree& in, compiler::resolution::path::Path const& path) {
      auto* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  
    inline Tree const& path_lookup(Tree const& in, compiler::resolution::path::Path const& path) {
      auto const* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  inline std::uint64_t children_count_of(Tree const& in) {
    return in.visit([&]<class T>(T const& part) -> std::uint64_t {
      if constexpr(std::is_same_v<T, Apply>) {
        return 2;
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        return 2;
      }
      if constexpr(std::is_same_v<T, Local>) {
        return 0;
      }
      if constexpr(std::is_same_v<T, Hole>) {
        return 0;
      }
      if constexpr(std::is_same_v<T, Embed>) {
        return 0;
      }
    });
  }
  inline bool is_child_valid(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T part) -> bool {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return true;
        
        case 1: return true;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return true;
        
        case 1: return true;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Local>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Embed>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }
  
  namespace detail {
    struct IteratorOutput {
      compiler::resolution::path::Path const& path;
      Tree& value;
    };
    class Iterator {
      compiler::resolution::path::Path path;
      std::vector<Tree*> stack;
      friend bool operator==(Iterator const& lhs, Iterator const& rhs) {
        return lhs.stack == rhs.stack && lhs.path == rhs.path;
      }
    public:
      Iterator() = default;
      explicit Iterator(Tree& base):stack{&base}{}
      IteratorOutput operator*() const {
        return {
          .path = path,
          .value = *stack.back()
        };
      }
      Iterator& operator++() {
        path.steps.push_back(0); //start looking at the first child of the given node
        while(!stack.empty()) {
          auto& back = *stack.back();
          auto& path_back = path.steps.back();
          auto max_steps = children_count_of(back);
          for(;path_back < max_steps;++path_back) {
            if(is_child_valid(back, path_back)) {
              stack.push_back(&path_step(back, path_back));
              return *this;
            }
          }
          stack.pop_back(); //step outwards
          path.steps.pop_back();
          if(!path.steps.empty()) {
            ++path.steps.back(); //look at next child of given node
          }
        }
        return *this;
      }
    };
  }
  struct TreeRecursiveIterator {
    Tree& tree;
    detail::Iterator begin() const {
      return detail::Iterator{tree};
    }
    detail::Iterator end() const {
      return {};
    }
  };
  inline TreeRecursiveIterator recursive_range(Tree& tree) {
    return {.tree = tree};
  }
  
  
  namespace detail {
    struct IteratorOutputConst {
      compiler::resolution::path::Path const& path;
      Tree const& value;
    };
    class IteratorConst {
      compiler::resolution::path::Path path;
      std::vector<Tree const*> stack;
      friend bool operator==(IteratorConst const& lhs, IteratorConst const& rhs) {
        return lhs.stack == rhs.stack && lhs.path == rhs.path;
      }
    public:
      IteratorConst() = default;
      explicit IteratorConst(Tree const& base):stack{&base}{}
      IteratorOutputConst operator*() const {
        return {
          .path = path,
          .value = *stack.back()
        };
      }
      IteratorConst& operator++() {
        path.steps.push_back(0); //start looking at the first child of the given node
        while(!stack.empty()) {
          auto const& back = *stack.back();
          auto& path_back = path.steps.back();
          auto max_steps = children_count_of(back);
          for(;path_back < max_steps;++path_back) {
            if(is_child_valid(back, path_back)) {
              stack.push_back(&path_step(back, path_back));
              return *this;
            }
          }
          stack.pop_back(); //step outwards
          path.steps.pop_back();
          if(!path.steps.empty()) {
            ++path.steps.back(); //look at next child of given node
          }
        }
        return *this;
      }
    };
  }
  struct TreeRecursiveIteratorConst {
    Tree const& tree;
    detail::IteratorConst begin() const {
      return detail::IteratorConst{tree};
    }
    detail::IteratorConst end() const {
      return {};
    }
  };
  inline TreeRecursiveIteratorConst recursive_range(Tree const& tree) {
    return {.tree = tree};
  }
  
  namespace match_result {
    
    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
  	};
    template<class Lhs, class Rhs> Apply(Lhs&&, Rhs&&) -> Apply<Lhs, Rhs>;
  	
    template<class Body, class Type>
  	struct Lambda {
  		Body body;
  		Type type;
  	};
    template<class Body, class Type> Lambda(Body&&, Type&&) -> Lambda<Body, Type>;
  	
    template<class StackIndex>
  	struct Local {
  		StackIndex stack_index;
  	};
    template<class StackIndex> Local(StackIndex&&) -> Local<StackIndex>;
  	
  	struct Hole {
  	};
  	
    template<class EmbedIndex>
  	struct Embed {
  		EmbedIndex embed_index;
  	};
    template<class EmbedIndex> Embed(EmbedIndex&&) -> Embed<EmbedIndex>;
  	
  }
  namespace match {
    struct Any {
      template<class T>
      bool check(T const&) const { return true; }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    struct None {
      template<class T>
      bool check(std::optional<T> const& opt) const { return !opt.has_value(); }
      template<class T>
      auto match(T&& value) { return std::nullopt; }
    };
    template<class Inner>
    struct Some {
      Inner inner;
      template<class T>
      bool check(std::optional<T> const& opt) const { return opt.has_value() && inner.check(*opt); }
      template<class T>
      T match(std::optional<T>&& value) { return std::move(*value); }
      template<class T>
      T& match(std::optional<T>& value) { return *value; }
      template<class T>
      T const& match(std::optional<T> const& value) { return *value; }
    };
    template<class Matcher, class Test>
    struct Filter {
      Matcher matcher;
      Test test;
      template<class T>
      bool check(T const& value) const { return matcher(value) && test(value); }
      template<class T>
      decltype(auto) match(T&& value) const { return matcher(std::forward<T>(value)); }
    };
    template<class Matcher, class Test> Filter(Matcher, Test) -> Filter<Matcher, Test>;
    template<class Test>
    struct Predicate {
      Test test;
      template<class T>
      bool check(T const& value) const { return test(value); }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    template<class Test> Predicate(Test) -> Predicate<Test>;
    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
    template<class Body, class Type>
  	struct Lambda {
  		Body body;
  		Type type;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type> Lambda(Body, Type) -> Lambda<Body, Type>;
  	struct Local {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_local();
        return match_result::Local{
            .stack_index = component.stack_index
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_local();
        return match_result::Local{
            .stack_index = std::move(component.stack_index)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_local();
        return match_result::Local{
            .stack_index = component.stack_index
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  	struct Hole {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  	struct Embed {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_embed();
        return match_result::Embed{
            .embed_index = component.embed_index
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_embed();
        return match_result::Embed{
            .embed_index = std::move(component.embed_index)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_embed();
        return match_result::Embed{
            .embed_index = component.embed_index
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  }
  namespace full_match {
    template<class Lhs, class Rhs>
    struct Apply {
      Lhs lhs;
      Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
    template<class Body, class Type>
    struct Lambda {
      Body body;
      Type type;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type> Lambda(Body, Type) -> Lambda<Body, Type>;
    template<class StackIndex>
    struct Local {
      StackIndex stack_index;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_local()) {
          return stack_index.check(component->stack_index);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_local();
        return match_result::Local{
            .stack_index = stack_index.match(component.stack_index)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_local();
        return match_result::Local{
            .stack_index = stack_index.match(std::move(component.stack_index))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_local();
        return match_result::Local{
            .stack_index = stack_index.match(component.stack_index)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class StackIndex> Local(StackIndex) -> Local<StackIndex>;
    struct Hole {
      bool check(Tree const& tree) const {
        return true;
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class EmbedIndex>
    struct Embed {
      EmbedIndex embed_index;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_embed()) {
          return embed_index.check(component->embed_index);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_embed();
        return match_result::Embed{
            .embed_index = embed_index.match(component.embed_index)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_embed();
        return match_result::Embed{
            .embed_index = embed_index.match(std::move(component.embed_index))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_embed();
        return match_result::Embed{
            .embed_index = embed_index.match(component.embed_index)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class EmbedIndex> Embed(EmbedIndex) -> Embed<EmbedIndex>;
  }	bool operator==(Tree const& lhs, Tree const& rhs);

	inline bool operator==(Apply const& lhs, Apply const& rhs) {
		return lhs.lhs == rhs.lhs
		    && lhs.rhs == rhs.rhs;
	}
	inline bool operator==(Lambda const& lhs, Lambda const& rhs) {
		return lhs.body == rhs.body
		    && lhs.type == rhs.type;
	}
	inline bool operator==(Local const& lhs, Local const& rhs) {
		return lhs.stack_index == rhs.stack_index;
	}
	inline bool operator==(Hole const& lhs, Hole const& rhs) {
		return true;
		
	}
	inline bool operator==(Embed const& lhs, Embed const& rhs) {
		return lhs.embed_index == rhs.embed_index;
	}
	

	inline bool operator==(Tree const& lhs, Tree const& rhs) {
		return lhs.visit(mdb::overloaded{
			[&](Apply const& component) {
				if(auto* other = rhs.get_if_apply()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Lambda const& component) {
				if(auto* other = rhs.get_if_lambda()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Local const& component) {
				if(auto* other = rhs.get_if_local()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Hole const& component) {
				if(auto* other = rhs.get_if_hole()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Embed const& component) {
				if(auto* other = rhs.get_if_embed()) {
					return component == *other;
				} else {
					return false;
				}
			}
		});
	}
	template<class Formatter>
	void format_indented(std::ostream& o, Tree const& value, std::size_t indent, Formatter&& format_inner = [](auto& o, auto const& v) { o << v; }) {
		auto make_indent = [&] { for(std::size_t i = 0; i < indent; ++i) o << "   "; };
		auto make_inner_indent = [&] { for(std::size_t i = 0; i <= indent; ++i) o << "   "; };
		value.visit(mdb::overloaded{
			[&](Apply const& component) {
				o << "Apply {\n";
				make_inner_indent(); o << ".lhs = "; format_indented(o, component.lhs, indent + 1, format_inner); o << "\n";
				make_inner_indent(); o << ".rhs = "; format_indented(o, component.rhs, indent + 1, format_inner); o << "\n";
				make_indent(); o << "}";
			},
			[&](Lambda const& component) {
				o << "Lambda {\n";
				make_inner_indent(); o << ".body = "; format_indented(o, component.body, indent + 1, format_inner); o << "\n";
				make_inner_indent(); o << ".type = "; format_indented(o, component.type, indent + 1, format_inner); o << "\n";
				make_indent(); o << "}";
			},
			[&](Local const& component) {
				o << "Local {\n";
				make_inner_indent(); o << ".stack_index = "; format_inner(o, component.stack_index); o << "\n";
				make_indent(); o << "}";
			},
			[&](Hole const& component) {
				o << "Hole {\n";
				make_indent(); o << "}";
			},
			[&](Embed const& component) {
				o << "Embed {\n";
				make_inner_indent(); o << ".embed_index = "; format_inner(o, component.embed_index); o << "\n";
				make_indent(); o << "}";
			}
		});
	}
	template<class Formatter>
	struct FormatTree {
		Tree const& tree;
		Formatter formatter;
	};
	template<class Formatter> FormatTree(Tree const&, Formatter&&) -> FormatTree<Formatter>;
	template<class Formatter>
	std::ostream& operator<<(std::ostream& o, FormatTree<Formatter> const& formatter) {
		format_indented(o, formatter.tree, 0, formatter.formatter);
		return o;
	}
}




namespace compiler::resolution::locator {

	struct Apply;
	struct Lambda;
	struct Local;
	struct Hole;
	struct Embed;

	class Tree {
		struct Impl;
		mdb::Indirect<Impl> data;
	public:
		Tree(Apply arg);
		Tree(Lambda arg);
		Tree(Local arg);
		Tree(Hole arg);
		Tree(Embed arg);
		
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		
		Lambda& get_lambda() &;
		Lambda const& get_lambda() const&;
		Lambda&& get_lambda() &&;
		Lambda* get_if_lambda();
		Lambda const* get_if_lambda() const;
		
		Local& get_local() &;
		Local const& get_local() const&;
		Local&& get_local() &&;
		Local* get_if_local();
		Local const* get_if_local() const;
		
		Hole& get_hole() &;
		Hole const& get_hole() const&;
		Hole&& get_hole() &&;
		Hole* get_if_hole();
		Hole const* get_if_hole() const;
		
		Embed& get_embed() &;
		Embed const& get_embed() const&;
		Embed&& get_embed() &&;
		Embed* get_if_embed();
		Embed const* get_if_embed() const;
		
		template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Local& local, Hole& hole, Embed& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Local&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Embed&> >;
})
		decltype(auto) visit(Visitor&&) &;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Local const& local, Hole const& hole, Embed const& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local const&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed const&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Local const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Embed const&> >;
})
		decltype(auto) visit(Visitor&&) const&;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Local&& local, Hole&& hole, Embed&& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Local&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Embed&&> >;
})
		decltype(auto) visit(Visitor&&) &&;

	};
	struct Apply {
		Tree lhs;
		Tree rhs;
		relative::Position relative_position;
	};
	struct Lambda {
		Tree body;
		Tree type;
		relative::Position relative_position;
	};
	struct Local {
		relative::Position relative_position;
	};
	struct Hole {
		relative::Position relative_position;
	};
	struct Embed {
		relative::Position relative_position;
	};
	

	struct Tree::Impl {
		std::variant<Apply, Lambda, Local, Hole, Embed> data;
	};
	
	inline Tree::Tree(Apply arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Lambda arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Local arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Hole arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Embed arg):data(mdb::in_place, std::move(arg)) {}
	
	inline Apply& Tree::get_apply() & { return std::get<Apply>(data->data); }
	inline Apply const& Tree::get_apply() const& { return std::get<Apply>(data->data); }
	inline Apply&& Tree::get_apply() && { return std::move(std::get<Apply>(data->data)); }
	inline Apply* Tree::get_if_apply() { return std::get_if<Apply>(&data->data); }
	inline Apply const* Tree::get_if_apply() const { return std::get_if<Apply>(&data->data); }
	
	inline Lambda& Tree::get_lambda() & { return std::get<Lambda>(data->data); }
	inline Lambda const& Tree::get_lambda() const& { return std::get<Lambda>(data->data); }
	inline Lambda&& Tree::get_lambda() && { return std::move(std::get<Lambda>(data->data)); }
	inline Lambda* Tree::get_if_lambda() { return std::get_if<Lambda>(&data->data); }
	inline Lambda const* Tree::get_if_lambda() const { return std::get_if<Lambda>(&data->data); }
	
	inline Local& Tree::get_local() & { return std::get<Local>(data->data); }
	inline Local const& Tree::get_local() const& { return std::get<Local>(data->data); }
	inline Local&& Tree::get_local() && { return std::move(std::get<Local>(data->data)); }
	inline Local* Tree::get_if_local() { return std::get_if<Local>(&data->data); }
	inline Local const* Tree::get_if_local() const { return std::get_if<Local>(&data->data); }
	
	inline Hole& Tree::get_hole() & { return std::get<Hole>(data->data); }
	inline Hole const& Tree::get_hole() const& { return std::get<Hole>(data->data); }
	inline Hole&& Tree::get_hole() && { return std::move(std::get<Hole>(data->data)); }
	inline Hole* Tree::get_if_hole() { return std::get_if<Hole>(&data->data); }
	inline Hole const* Tree::get_if_hole() const { return std::get_if<Hole>(&data->data); }
	
	inline Embed& Tree::get_embed() & { return std::get<Embed>(data->data); }
	inline Embed const& Tree::get_embed() const& { return std::get<Embed>(data->data); }
	inline Embed&& Tree::get_embed() && { return std::move(std::get<Embed>(data->data)); }
	inline Embed* Tree::get_if_embed() { return std::get_if<Embed>(&data->data); }
	inline Embed const* Tree::get_if_embed() const { return std::get_if<Embed>(&data->data); }
	

	template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Local& local, Hole& hole, Embed& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Local&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Embed&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) & {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Local const& local, Hole const& hole, Embed const& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local const&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed const&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Local const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Embed const&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) const& {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Local&& local, Hole&& hole, Embed&& embed) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Local&&>(local));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Embed&&>(embed));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Local&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Embed&&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) && {
		return std::visit(std::forward<Visitor>(visitor), std::move(data->data));
	}


inline std::uint64_t path_segment_of(Tree Apply::* member) {
  if(member == &Apply::lhs) return 0;
  if(member == &Apply::rhs) return 1;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(Tree Lambda::* member) {
  if(member == &Lambda::body) return 0;
  if(member == &Lambda::type) return 1;
  std::terminate(); //unreachable
}
template<class... Ts>
inline void path_append(compiler::resolution::path::Path& path, Ts&&... ts) {
  (path.steps.push_back(path_segment_of(ts)) , ...);
}
template<class... Ts>
inline compiler::resolution::path::Path path_of(Ts&&... ts) {
  compiler::resolution::path::Path ret;
  path_append(ret, std::forward<Ts>(ts)...);
  return ret;
}

  
  inline Tree& path_step(Tree& in, std::uint64_t step) {
    return in.visit([&]<class T>(T& part) -> Tree& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Local>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Embed>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }
  
  
  inline Tree const& path_step(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T const& part) -> Tree const& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Local>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Embed>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }
  
  
    inline Tree& path_lookup(Tree& in, compiler::resolution::path::Path const& path) {
      auto* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  
    inline Tree const& path_lookup(Tree const& in, compiler::resolution::path::Path const& path) {
      auto const* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  inline std::uint64_t children_count_of(Tree const& in) {
    return in.visit([&]<class T>(T const& part) -> std::uint64_t {
      if constexpr(std::is_same_v<T, Apply>) {
        return 2;
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        return 2;
      }
      if constexpr(std::is_same_v<T, Local>) {
        return 0;
      }
      if constexpr(std::is_same_v<T, Hole>) {
        return 0;
      }
      if constexpr(std::is_same_v<T, Embed>) {
        return 0;
      }
    });
  }
  inline bool is_child_valid(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T part) -> bool {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return true;
        
        case 1: return true;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return true;
        
        case 1: return true;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Local>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Embed>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }
  
  namespace detail {
    struct IteratorOutput {
      compiler::resolution::path::Path const& path;
      Tree& value;
    };
    class Iterator {
      compiler::resolution::path::Path path;
      std::vector<Tree*> stack;
      friend bool operator==(Iterator const& lhs, Iterator const& rhs) {
        return lhs.stack == rhs.stack && lhs.path == rhs.path;
      }
    public:
      Iterator() = default;
      explicit Iterator(Tree& base):stack{&base}{}
      IteratorOutput operator*() const {
        return {
          .path = path,
          .value = *stack.back()
        };
      }
      Iterator& operator++() {
        path.steps.push_back(0); //start looking at the first child of the given node
        while(!stack.empty()) {
          auto& back = *stack.back();
          auto& path_back = path.steps.back();
          auto max_steps = children_count_of(back);
          for(;path_back < max_steps;++path_back) {
            if(is_child_valid(back, path_back)) {
              stack.push_back(&path_step(back, path_back));
              return *this;
            }
          }
          stack.pop_back(); //step outwards
          path.steps.pop_back();
          if(!path.steps.empty()) {
            ++path.steps.back(); //look at next child of given node
          }
        }
        return *this;
      }
    };
  }
  struct TreeRecursiveIterator {
    Tree& tree;
    detail::Iterator begin() const {
      return detail::Iterator{tree};
    }
    detail::Iterator end() const {
      return {};
    }
  };
  inline TreeRecursiveIterator recursive_range(Tree& tree) {
    return {.tree = tree};
  }
  
  
  namespace detail {
    struct IteratorOutputConst {
      compiler::resolution::path::Path const& path;
      Tree const& value;
    };
    class IteratorConst {
      compiler::resolution::path::Path path;
      std::vector<Tree const*> stack;
      friend bool operator==(IteratorConst const& lhs, IteratorConst const& rhs) {
        return lhs.stack == rhs.stack && lhs.path == rhs.path;
      }
    public:
      IteratorConst() = default;
      explicit IteratorConst(Tree const& base):stack{&base}{}
      IteratorOutputConst operator*() const {
        return {
          .path = path,
          .value = *stack.back()
        };
      }
      IteratorConst& operator++() {
        path.steps.push_back(0); //start looking at the first child of the given node
        while(!stack.empty()) {
          auto const& back = *stack.back();
          auto& path_back = path.steps.back();
          auto max_steps = children_count_of(back);
          for(;path_back < max_steps;++path_back) {
            if(is_child_valid(back, path_back)) {
              stack.push_back(&path_step(back, path_back));
              return *this;
            }
          }
          stack.pop_back(); //step outwards
          path.steps.pop_back();
          if(!path.steps.empty()) {
            ++path.steps.back(); //look at next child of given node
          }
        }
        return *this;
      }
    };
  }
  struct TreeRecursiveIteratorConst {
    Tree const& tree;
    detail::IteratorConst begin() const {
      return detail::IteratorConst{tree};
    }
    detail::IteratorConst end() const {
      return {};
    }
  };
  inline TreeRecursiveIteratorConst recursive_range(Tree const& tree) {
    return {.tree = tree};
  }
  
  namespace match_result {
    
    template<class Lhs, class Rhs, class RelativePosition>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
  		RelativePosition relative_position;
  	};
    template<class Lhs, class Rhs, class RelativePosition> Apply(Lhs&&, Rhs&&, RelativePosition&&) -> Apply<Lhs, Rhs, RelativePosition>;
  	
    template<class Body, class Type, class RelativePosition>
  	struct Lambda {
  		Body body;
  		Type type;
  		RelativePosition relative_position;
  	};
    template<class Body, class Type, class RelativePosition> Lambda(Body&&, Type&&, RelativePosition&&) -> Lambda<Body, Type, RelativePosition>;
  	
    template<class RelativePosition>
  	struct Local {
  		RelativePosition relative_position;
  	};
    template<class RelativePosition> Local(RelativePosition&&) -> Local<RelativePosition>;
  	
    template<class RelativePosition>
  	struct Hole {
  		RelativePosition relative_position;
  	};
    template<class RelativePosition> Hole(RelativePosition&&) -> Hole<RelativePosition>;
  	
    template<class RelativePosition>
  	struct Embed {
  		RelativePosition relative_position;
  	};
    template<class RelativePosition> Embed(RelativePosition&&) -> Embed<RelativePosition>;
  	
  }
  namespace match {
    struct Any {
      template<class T>
      bool check(T const&) const { return true; }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    struct None {
      template<class T>
      bool check(std::optional<T> const& opt) const { return !opt.has_value(); }
      template<class T>
      auto match(T&& value) { return std::nullopt; }
    };
    template<class Inner>
    struct Some {
      Inner inner;
      template<class T>
      bool check(std::optional<T> const& opt) const { return opt.has_value() && inner.check(*opt); }
      template<class T>
      T match(std::optional<T>&& value) { return std::move(*value); }
      template<class T>
      T& match(std::optional<T>& value) { return *value; }
      template<class T>
      T const& match(std::optional<T> const& value) { return *value; }
    };
    template<class Matcher, class Test>
    struct Filter {
      Matcher matcher;
      Test test;
      template<class T>
      bool check(T const& value) const { return matcher(value) && test(value); }
      template<class T>
      decltype(auto) match(T&& value) const { return matcher(std::forward<T>(value)); }
    };
    template<class Matcher, class Test> Filter(Matcher, Test) -> Filter<Matcher, Test>;
    template<class Test>
    struct Predicate {
      Test test;
      template<class T>
      bool check(T const& value) const { return test(value); }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    template<class Test> Predicate(Test) -> Predicate<Test>;
    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs)),
            .relative_position = std::move(component.relative_position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
    template<class Body, class Type>
  	struct Lambda {
  		Body body;
  		Type type;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type)),
            .relative_position = std::move(component.relative_position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type> Lambda(Body, Type) -> Lambda<Body, Type>;
  	struct Local {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_local();
        return match_result::Local{
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_local();
        return match_result::Local{
            .relative_position = std::move(component.relative_position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_local();
        return match_result::Local{
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  	struct Hole {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
            .relative_position = std::move(component.relative_position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  	struct Embed {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_embed();
        return match_result::Embed{
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_embed();
        return match_result::Embed{
            .relative_position = std::move(component.relative_position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_embed();
        return match_result::Embed{
            .relative_position = component.relative_position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  }
  namespace full_match {
    template<class Lhs, class Rhs, class RelativePosition>
    struct Apply {
      Lhs lhs;
      Rhs rhs;
      RelativePosition relative_position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs)
              && relative_position.check(component->relative_position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs)),
            .relative_position = relative_position.match(std::move(component.relative_position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs, class RelativePosition> Apply(Lhs, Rhs, RelativePosition) -> Apply<Lhs, Rhs, RelativePosition>;
    template<class Body, class Type, class RelativePosition>
    struct Lambda {
      Body body;
      Type type;
      RelativePosition relative_position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type)
              && relative_position.check(component->relative_position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type)),
            .relative_position = relative_position.match(std::move(component.relative_position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type, class RelativePosition> Lambda(Body, Type, RelativePosition) -> Lambda<Body, Type, RelativePosition>;
    template<class RelativePosition>
    struct Local {
      RelativePosition relative_position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_local()) {
          return relative_position.check(component->relative_position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_local();
        return match_result::Local{
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_local();
        return match_result::Local{
            .relative_position = relative_position.match(std::move(component.relative_position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_local();
        return match_result::Local{
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class RelativePosition> Local(RelativePosition) -> Local<RelativePosition>;
    template<class RelativePosition>
    struct Hole {
      RelativePosition relative_position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_hole()) {
          return relative_position.check(component->relative_position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
            .relative_position = relative_position.match(std::move(component.relative_position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class RelativePosition> Hole(RelativePosition) -> Hole<RelativePosition>;
    template<class RelativePosition>
    struct Embed {
      RelativePosition relative_position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_embed()) {
          return relative_position.check(component->relative_position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_embed();
        return match_result::Embed{
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_embed();
        return match_result::Embed{
            .relative_position = relative_position.match(std::move(component.relative_position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_embed();
        return match_result::Embed{
            .relative_position = relative_position.match(component.relative_position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class RelativePosition> Embed(RelativePosition) -> Embed<RelativePosition>;
  }	bool operator==(Tree const& lhs, Tree const& rhs);

	inline bool operator==(Apply const& lhs, Apply const& rhs) {
		return lhs.lhs == rhs.lhs
		    && lhs.rhs == rhs.rhs
		    && lhs.relative_position == rhs.relative_position;
	}
	inline bool operator==(Lambda const& lhs, Lambda const& rhs) {
		return lhs.body == rhs.body
		    && lhs.type == rhs.type
		    && lhs.relative_position == rhs.relative_position;
	}
	inline bool operator==(Local const& lhs, Local const& rhs) {
		return lhs.relative_position == rhs.relative_position;
	}
	inline bool operator==(Hole const& lhs, Hole const& rhs) {
		return lhs.relative_position == rhs.relative_position;
	}
	inline bool operator==(Embed const& lhs, Embed const& rhs) {
		return lhs.relative_position == rhs.relative_position;
	}
	

	inline bool operator==(Tree const& lhs, Tree const& rhs) {
		return lhs.visit(mdb::overloaded{
			[&](Apply const& component) {
				if(auto* other = rhs.get_if_apply()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Lambda const& component) {
				if(auto* other = rhs.get_if_lambda()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Local const& component) {
				if(auto* other = rhs.get_if_local()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Hole const& component) {
				if(auto* other = rhs.get_if_hole()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Embed const& component) {
				if(auto* other = rhs.get_if_embed()) {
					return component == *other;
				} else {
					return false;
				}
			}
		});
	}
	template<class Formatter>
	void format_indented(std::ostream& o, Tree const& value, std::size_t indent, Formatter&& format_inner = [](auto& o, auto const& v) { o << v; }) {
		auto make_indent = [&] { for(std::size_t i = 0; i < indent; ++i) o << "   "; };
		auto make_inner_indent = [&] { for(std::size_t i = 0; i <= indent; ++i) o << "   "; };
		value.visit(mdb::overloaded{
			[&](Apply const& component) {
				o << "Apply {\n";
				make_inner_indent(); o << ".lhs = "; format_indented(o, component.lhs, indent + 1, format_inner); o << "\n";
				make_inner_indent(); o << ".rhs = "; format_indented(o, component.rhs, indent + 1, format_inner); o << "\n";
				make_inner_indent(); o << ".relative_position = "; format_inner(o, component.relative_position); o << "\n";
				make_indent(); o << "}";
			},
			[&](Lambda const& component) {
				o << "Lambda {\n";
				make_inner_indent(); o << ".body = "; format_indented(o, component.body, indent + 1, format_inner); o << "\n";
				make_inner_indent(); o << ".type = "; format_indented(o, component.type, indent + 1, format_inner); o << "\n";
				make_inner_indent(); o << ".relative_position = "; format_inner(o, component.relative_position); o << "\n";
				make_indent(); o << "}";
			},
			[&](Local const& component) {
				o << "Local {\n";
				make_inner_indent(); o << ".relative_position = "; format_inner(o, component.relative_position); o << "\n";
				make_indent(); o << "}";
			},
			[&](Hole const& component) {
				o << "Hole {\n";
				make_inner_indent(); o << ".relative_position = "; format_inner(o, component.relative_position); o << "\n";
				make_indent(); o << "}";
			},
			[&](Embed const& component) {
				o << "Embed {\n";
				make_inner_indent(); o << ".relative_position = "; format_inner(o, component.relative_position); o << "\n";
				make_indent(); o << "}";
			}
		});
	}
	template<class Formatter>
	struct FormatTree {
		Tree const& tree;
		Formatter formatter;
	};
	template<class Formatter> FormatTree(Tree const&, Formatter&&) -> FormatTree<Formatter>;
	template<class Formatter>
	std::ostream& operator<<(std::ostream& o, FormatTree<Formatter> const& formatter) {
		format_indented(o, formatter.tree, 0, formatter.formatter);
		return o;
	}
}


namespace compiler::resolution::located_output {
  struct Apply;
  struct Lambda;
  struct Local;
  struct Hole;
  struct Embed;

	struct Tree {
    compiler::resolution::output::Tree output;
    compiler::resolution::locator::Tree locator;
		Tree(Apply arg);
		Tree(Lambda arg);
		Tree(Local arg);
		Tree(Hole arg);
		Tree(Embed arg);
	};
	struct Apply {
		Tree lhs;
		Tree rhs;
    relative::Position relative_position;
	};
	struct Lambda {
		Tree body;
		Tree type;
    relative::Position relative_position;
	};
	struct Local {
    std::uint64_t stack_index;
    relative::Position relative_position;
	};
	struct Hole {
    relative::Position relative_position;
	};
	struct Embed {
    std::uint64_t embed_index;
    relative::Position relative_position;
	};

  inline Tree::Tree(Apply arg):
    output([&]() -> compiler::resolution::output::Tree {
      return compiler::resolution::output::Apply{
        .lhs = std::move(arg.lhs.output),
        .rhs = std::move(arg.rhs.output)
      };
    }()),
    locator([&]() -> compiler::resolution::locator::Tree {
      return compiler::resolution::locator::Apply{
        .lhs = std::move(arg.lhs.locator),
        .rhs = std::move(arg.rhs.locator),
        .relative_position = std::move(arg.relative_position)
      };
    }())
  {}
  inline Tree::Tree(Lambda arg):
    output([&]() -> compiler::resolution::output::Tree {
      return compiler::resolution::output::Lambda{
        .body = std::move(arg.body.output),
        .type = std::move(arg.type.output)
      };
    }()),
    locator([&]() -> compiler::resolution::locator::Tree {
      return compiler::resolution::locator::Lambda{
        .body = std::move(arg.body.locator),
        .type = std::move(arg.type.locator),
        .relative_position = std::move(arg.relative_position)
      };
    }())
  {}
  inline Tree::Tree(Local arg):
    output([&]() -> compiler::resolution::output::Tree {
      return compiler::resolution::output::Local{
        .stack_index = std::move(arg.stack_index)
      };
    }()),
    locator([&]() -> compiler::resolution::locator::Tree {
      return compiler::resolution::locator::Local{
        .relative_position = std::move(arg.relative_position)
      };
    }())
  {}
  inline Tree::Tree(Hole arg):
    output([&]() -> compiler::resolution::output::Tree {
      return compiler::resolution::output::Hole{
      };
    }()),
    locator([&]() -> compiler::resolution::locator::Tree {
      return compiler::resolution::locator::Hole{
        .relative_position = std::move(arg.relative_position)
      };
    }())
  {}
  inline Tree::Tree(Embed arg):
    output([&]() -> compiler::resolution::output::Tree {
      return compiler::resolution::output::Embed{
        .embed_index = std::move(arg.embed_index)
      };
    }()),
    locator([&]() -> compiler::resolution::locator::Tree {
      return compiler::resolution::locator::Embed{
        .relative_position = std::move(arg.relative_position)
      };
    }())
  {}
}

