axiom zero;
axiom succ;

axiom cons;
axiom nil;

declare at;
rule at zero (cons head tail) := head;
rule at (succ n) (cons head tail) := at n tail;

test at (succ zero) (cons zero (cons succ (cons zero)));
expect succ;

axiom apply;
axiom primitive;
axiom lambda;
axiom argument;

declare execute;
rule execute ctx (apply f x) := (execute ctx f) (execute ctx x);
rule execute ctx (primitive v) := v;
rule execute ctx (argument n) := at n ctx;
rule execute ctx (lambda b) := \v.(execute (cons v ctx) b);

test execute nil (primitive zero);
expect zero;
test execute nil (apply (apply (primitive execute) (primitive nil)) (apply (primitive lambda) (apply (primitive argument) (primitive zero))));
expect \a.a;
test execute nil (lambda (lambda (lambda (argument (succ (succ zero))))));
expect \a.\b.\c.a;

declare induct;
rule induct f s zero := s;
rule induct f s (succ n) := f n (induct f s n);

test \f.\x.induct (\.f) x zero;
expect \f.\x.x;
test \f.\x.induct (\.f) x (succ zero);
expect \f.\x.f x;
test \f.\x.induct (\.f) x (succ (succ zero));
expect \f.\x.f (f x);
test \f.\x.induct (\.f) x (succ (succ (succ zero)));
expect \f.\x.f (f (f x));

test \f.\x.induct f x zero;
expect \f.\x.x;
test \f.\x.induct f x (succ zero);
expect \f.\x.f zero x;
test \f.\x.induct f x (succ (succ zero));
expect \f.\x.f (succ zero) (f zero x);
test \f.\x.induct f x (succ (succ (succ zero)));
expect \f.\x.f (succ (succ zero)) (f (succ zero) (f zero x));

test \f.\x.\n.induct f x (succ (succ n));
expect \f.\x.\n.f (succ n) (f n (induct f x n));

alias add := induct (\.succ);
test add (succ zero) (succ (succ zero));
expect succ (succ (succ zero));

alias times := \n.induct (\.add n) zero;
test times (succ (succ zero)) (succ (succ (succ zero)));
expect succ (succ (succ (succ (succ (succ zero)))));

alias pow := \n.induct (\.times n) (succ zero);
test pow (succ (succ zero)) (succ (succ (succ zero)));
expect succ (succ (succ (succ (succ (succ (succ (succ zero)))))));

alias acc := induct add zero;
test acc (succ (succ (succ (succ zero))));
expect succ (succ (succ (succ (succ (succ zero)))));

alias weird := induct (\n.\v.times n (succ v)) zero;
test weird (succ (succ (succ zero)));
expect succ (succ (succ (succ zero)));
