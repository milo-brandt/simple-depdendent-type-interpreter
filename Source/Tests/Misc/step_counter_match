# TEST BEGIN
# TEST NAME A complex definition counting the steps to zero works using a match statement.
# TEST MUST_COMPILE

block {
  axiom Bool : Type;
  axiom yes : Bool;
  axiom no : Bool;

  axiom Nat : Type;
  axiom zero : Nat;
  axiom succ : Nat -> Nat;

  declare nat_to_u64 : Nat -> U64;
  nat_to_u64 zero = 0;
  nat_to_u64 (succ n) = add 1 (nat_to_u64 n);

  declare count_steps_to_zero : Nat -> (Nat -> Nat) -> Nat -> Nat;
  count_steps_to_zero zero f base = zero;
  count_steps_to_zero (succ max_steps) f base = block {
    match(base) {
      zero -> zero;
      succ n -> succ \\ count_steps_to_zero max_steps f (f base);
    }
  };

  declare f : Nat -> Nat;
  f zero = succ zero;
  f (succ n) = n;

  verify count_steps_to_zero (succ zero) f zero = zero;
  verify count_steps_to_zero (succ zero) f (succ zero) = succ zero;
  verify count_steps_to_zero (succ zero) f (succ \\ succ zero) = succ zero;

  verify count_steps_to_zero (succ \\ succ zero) f zero = zero;
  verify count_steps_to_zero (succ \\ succ zero) f (succ zero) = succ zero;
  verify count_steps_to_zero (succ \\ succ zero) f (succ \\ succ zero) = succ \\ succ zero;

  yes
}
