# TEST BEGIN
# TEST NAME A program implementing a stack machine with finitely many instructions (each of fixed state size) works as expected.
# TEST MUST_COMPILE

block {
  axiom Id : (T : Type) -> T -> T -> Type;
  axiom refl : (T : Type) -> (x : T) -> Id T x x;

  axiom Bool : Type;
  axiom yes : Bool;
  axiom no : Bool;

  axiom Nat : Type;
  axiom zero : Nat;
  axiom succ : Nat -> Nat;

  axiom Fin : Nat -> Type;
  axiom fzero : (n : Nat) -> Fin (succ n);
  axiom fsucc : (n : Nat) -> Fin n -> Fin (succ n);

  axiom Transition : (n : Nat) -> (state_size : Fin n -> Nat) -> (input_state_size : Nat) -> Type;
  axiom repush :
      (n : Nat)
   -> (state_size : Fin n -> Nat)
   -> (input_state_size : Nat)
   -> (stack_index : Fin input_state_size)
   -> (output_state : Fin n)
   -> Id _ (state_size output_state) (succ input_state_size)
   -> Transition n state_size input_state_size;
  axiom drop :
      (n : Nat)
   -> (state_size : Fin n -> Nat)
   -> (input_state_size : Nat)
   -> (stack_index : Fin input_state_size)
   -> (output_state : Fin n)
   -> Id _ (succ \\ state_size output_state) input_state_size
   -> Transition n state_size input_state_size;
  axiom sum_top :
      (n : Nat)
   -> (state_size : Fin n -> Nat)
   -> (input_ignore_size : Nat)
   -> (output_state : Fin n)
   -> Id _ (state_size output_state) (succ input_ignore_size)
   -> Transition n state_size (succ \\ succ input_ignore_size);

  axiom StackProgram : Type;
  axiom stack_program :
      (n           : Nat)       # number of states
   -> (state_size  : Fin n -> Nat)  # number of args in nth state
   -> (transition  : (x : Fin n) -> Transition n state_size (state_size x))
   -> StackProgram;

   axiom State : StackProgram -> Type;
   axiom state :
      (n           : Nat)       # number of states
   -> (state_size  : Fin n -> Nat)  # number of args in nth state
   -> (transition  : (x : Fin n) -> Transition n state_size (state_size x))
   -> (state : Fin n)
   -> (values : Fin (state_size state) -> U64)
   -> State (stack_program n state_size transition);

   declare avoid_fin : (n : Nat) -> (m : Fin (succ n)) -> Fin n -> Fin (succ n);
   avoid_fin n (fzero _) x = fsucc _ x;
   avoid_fin n (fsucc _ prev) (fzero _) = fzero _;
   avoid_fin (succ m) (fsucc _ prev) (fsucc _ prev_x) = fsucc _ (avoid_fin m prev prev_x);

   declare Stack : Nat -> Type;
   Stack n = Fin n -> U64;

   declare drop_stack : (n : Nat) -> Stack (succ n) -> Fin (succ n) -> Stack n;
   drop_stack n stack dropped_index = \i.stack (avoid_fin _ dropped_index i);

   declare repush_stack : (n : Nat) -> Stack n -> Fin n -> Stack (succ n);
   repush_stack n stack pushed_index = \i.match(i) {
     fzero _ -> stack pushed_index;
     fsucc _ prev -> stack prev;
   };

   declare sum_stack : (n : Nat) -> Stack (succ \\ succ n) -> Stack (succ n);
   sum_stack n stack = \i.match(i) {
     fzero _ -> add (stack \\ fzero _) (stack \\ fsucc _ \\ fzero _);
     fsucc _ prev -> stack (fsucc _ \\ fsucc _ \\ prev);
   };



   declare advance : (program : StackProgram) -> State program -> State program;
   advance
    (stack_program _ _ transition)
    (state _ _ _ state_index values)
   = match(transition state_index) {
      repush _ _ _ index next (refl _ _) ->
        state _ _ _ next (repush_stack _ values index);
      drop _ _ _ index next (refl _ _) ->
        state _ _ _ next (drop_stack _ values index);
      sum_top _ _ _ next (refl _ _) ->
        state _ _ _ next (sum_stack _ values);
   };


    declare program_size_of : StackProgram -> Nat;
    program_size_of (stack_program n _ _) = n;

    declare stack_size_of : (program : StackProgram) -> (m : Fin \\ program_size_of program) -> Nat;
    stack_size_of (stack_program _ stack_size _) = stack_size;

    declare current_state : (program : StackProgram) -> (state : State program) -> Fin \\ program_size_of program;
    current_state _ (state _ _ _ v _) = v;

    declare stack_of : (program : StackProgram) -> (state : State program) -> Stack (stack_size_of program \\ current_state _ state);
    stack_of _ (state _ _ _ _ stack) = stack;

   # The following program:
   # 0 (size 2) -> repush 1 and go to 1
   # 1 (size 3) -> add
   let multiples_program = stack_program
      (succ \\ succ zero)
      (\i.match(i) {
        fzero _ -> succ \\ succ zero;
        fsucc _ prev -> succ \\ succ \\ succ zero;
      })
      (\i.match(i) {
        fzero _ -> repush _ _ _ (fsucc _ \\ fzero _) (fsucc _ \\ fzero _) (refl _ _);
        fsucc _ prev -> sum_top _ _ _ (fzero _) (refl _ _);
      });

   let odd_stack : Stack (succ \\ succ zero) = \i.match(i) {
     fzero _ -> 1;
     fsucc _ prev -> 2;
   };
   let odd_state : State multiples_program = state _ _ _ (fzero _) odd_stack;

   verify stack_of multiples_program (advance _ odd_state) (fzero _) = 2;
   verify stack_of multiples_program (advance _ odd_state) (fsucc _ \\ fzero _) = 1;
   verify stack_of multiples_program (advance _ odd_state) (fsucc _ \\ fsucc _ \\ fzero _) = 2;
   verify stack_of multiples_program (advance _ \\ advance _ odd_state) (fzero _) = 3;
   verify stack_of multiples_program (advance _ \\ advance _ odd_state) (fsucc _ \\ fzero _) = 2;
   verify stack_of multiples_program (advance _ \\ advance _ \\ advance _ odd_state) (fzero _) = 2;
   verify stack_of multiples_program (advance _ \\ advance _ \\ advance _ odd_state) (fsucc _ \\ fzero _) = 3;
   verify stack_of multiples_program (advance _ \\ advance _ \\ advance _ odd_state) (fsucc _ \\ fsucc _ \\ fzero _) = 2;
   verify stack_of multiples_program (advance _ \\ advance _ \\ advance _ \\ advance _ odd_state) (fzero _) = 5;
   verify stack_of multiples_program (advance _ \\ advance _ \\ advance _ \\ advance _ odd_state) (fsucc _ \\ fzero _) = 2;

   # The following program:
   # 0 (size 2) -> repush 1 and go to 1
   # 1 (size 3) -> repush 1 and go to 2
   # 2 (size 4) -> add and go to 3
   # 3 (size 3) -> drop 2 and go to 0
   let fib_program = stack_program
      (succ \\ succ \\ succ \\ succ zero)
      (\i.match(i) {
        fzero _ -> succ \\ succ zero;
        fsucc _ (fzero _) -> succ \\ succ \\ succ zero;
        fsucc _ (fsucc _ (fzero _)) -> succ \\ succ \\ succ \\ succ zero;
        fsucc _ (fsucc _ (fsucc _ (fzero _))) -> succ \\ succ \\ succ zero;
      })
      (\i.match(i) {
        fzero _ -> repush _ _ _ (fsucc _ \\ fzero _) (fsucc _ \\ fzero _) (refl _ _);
        fsucc _ (fzero _) -> repush _ _ _ (fsucc _ \\ fzero _) (fsucc _ \\ fsucc _ \\ fzero _) (refl _ _);
        fsucc _ (fsucc _ (fzero _)) -> sum_top _ _ _ (fsucc _ \\ fsucc _ \\ fsucc _ \\ fzero _) (refl _ _);
        fsucc _ (fsucc _ (fsucc _ (fzero _))) -> drop _ _ _ (fsucc _ \\ fsucc _ \\ fzero _) (fzero _) (refl _ _);
      });
    let start_stack : Stack (succ \\ succ zero) = \i.match(i) {
      fzero _ -> 2;
      fsucc _ prev -> 1;
    };
    let start_state : State fib_program = state _ _ _ (fzero _) start_stack;

    verify stack_of _ (advance _ start_state) (fzero _) = 1;
    verify stack_of _ (advance _ start_state) (fsucc _ \\ fzero _) = 2;
    verify stack_of _ (advance _ start_state) (fsucc _ \\ fsucc _ \\ fzero _) = 1;
    verify stack_of _ (advance _ \\ advance _ start_state) (fzero _) = 2;
    verify stack_of _ (advance _ \\ advance _ start_state) (fsucc _ \\ fzero _) = 1;
    verify stack_of _ (advance _ \\ advance _ start_state) (fsucc _ \\ fsucc _ \\ fzero _) = 2;
    verify stack_of _ (advance _ \\ advance _ start_state) (fsucc _ \\ fsucc _ \\ fsucc _ \\ fzero _) = 1;
    verify stack_of _ (advance _ \\ advance _ \\ advance _ start_state) (fzero _) = 3;
    verify stack_of _ (advance _ \\ advance _ \\ advance _ start_state) (fsucc _ \\ fzero _) = 2;
    verify stack_of _ (advance _ \\ advance _ \\ advance _ start_state) (fsucc _ \\ fsucc _ \\ fzero _) = 1;
    verify stack_of _ (advance _ \\ advance _ \\ advance _ \\ advance _ start_state) (fzero _) = 3;
    verify stack_of _ (advance _ \\ advance _ \\ advance _ \\ advance _ start_state) (fsucc _ \\ fzero _) = 2;

    let advance_4 = \s:State fib_program.advance _ \\ advance _ \\ advance _ \\ advance _ s;
    verify stack_of _ (advance_4 start_state) (fzero _) = 3;
    verify stack_of _ (advance_4 start_state) (fsucc _ \\ fzero _) = 2;
    verify stack_of _ (advance_4 \\ advance_4 start_state) (fzero _) = 5;
    verify stack_of _ (advance_4 \\ advance_4 start_state) (fsucc _ \\ fzero _) = 3;
    verify stack_of _ (advance_4 \\ advance_4 \\ advance_4 start_state) (fzero _) = 8;
    verify stack_of _ (advance_4 \\ advance_4 \\ advance_4 start_state) (fsucc _ \\ fzero _) = 5;
    verify stack_of _ (advance_4 \\ advance_4 \\ advance_4 \\ advance_4 start_state) (fzero _) = 13;
    verify stack_of _ (advance_4 \\ advance_4 \\ advance_4 \\ advance_4 start_state) (fsucc _ \\ fzero _) = 8;

   zero
}
