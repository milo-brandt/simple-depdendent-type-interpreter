/*
This file is automatically generated! Please do not make edits to it as they will be overwritten in the build process. Edits should instead be made to...
...the specification for this file: 
...the script which generates these files: 
*/

#include "../Utility/indirect.hpp"
#include <variant>
#include <type_traits>
#include <vector>
#include <optional>
#include <cstdint>

namespace expression_parser::path {
  struct Path {
    std::vector<std::uint64_t> steps;
  };
}



namespace expression_parser::output {

	struct Apply;
	struct Lambda;
	struct Identifier;
	struct Hole;
	struct Arrow;

	class Tree {
		struct Impl;
		mdb::Indirect<Impl> data;
	public:
		Tree(Apply arg);
		Tree(Lambda arg);
		Tree(Identifier arg);
		Tree(Hole arg);
		Tree(Arrow arg);
		
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		
		Lambda& get_lambda() &;
		Lambda const& get_lambda() const&;
		Lambda&& get_lambda() &&;
		Lambda* get_if_lambda();
		Lambda const* get_if_lambda() const;
		
		Identifier& get_identifier() &;
		Identifier const& get_identifier() const&;
		Identifier&& get_identifier() &&;
		Identifier* get_if_identifier();
		Identifier const* get_if_identifier() const;
		
		Hole& get_hole() &;
		Hole const& get_hole() const&;
		Hole&& get_hole() &&;
		Hole* get_if_hole();
		Hole const* get_if_hole() const;
		
		Arrow& get_arrow() &;
		Arrow const& get_arrow() const&;
		Arrow&& get_arrow() &&;
		Arrow* get_if_arrow();
		Arrow const* get_if_arrow() const;
		
		template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&> >;
})
		decltype(auto) visit(Visitor&&) &;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier const&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow const&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&> >;
})
		decltype(auto) visit(Visitor&&) const&;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Identifier&& identifier, Hole&& hole, Arrow&& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&> >;
})
		decltype(auto) visit(Visitor&&) &&;

	};
	struct Apply {
		Tree lhs;
		Tree rhs;
	};
	struct Lambda {
		Tree body;
		std::optional<Tree> type;
		std::optional<std::string_view> arg_name;
	};
	struct Identifier {
		std::string_view id;
	};
	struct Hole {
	};
	struct Arrow {
		Tree domain;
		Tree codomain;
		std::optional<std::string_view> arg_name;
	};
	

	struct Tree::Impl {
		std::variant<Apply, Lambda, Identifier, Hole, Arrow> data;
	};
	
	Tree::Tree(Apply arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Lambda arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Identifier arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Hole arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Arrow arg):data(mdb::in_place, std::move(arg)) {}
	
	Apply& Tree::get_apply() & { return std::get<Apply>(data->data); }
	Apply const& Tree::get_apply() const& { return std::get<Apply>(data->data); }
	Apply&& Tree::get_apply() && { return std::move(std::get<Apply>(data->data)); }
	Apply* Tree::get_if_apply() { return std::get_if<Apply>(&data->data); }
	Apply const* Tree::get_if_apply() const { return std::get_if<Apply>(&data->data); }
	
	Lambda& Tree::get_lambda() & { return std::get<Lambda>(data->data); }
	Lambda const& Tree::get_lambda() const& { return std::get<Lambda>(data->data); }
	Lambda&& Tree::get_lambda() && { return std::move(std::get<Lambda>(data->data)); }
	Lambda* Tree::get_if_lambda() { return std::get_if<Lambda>(&data->data); }
	Lambda const* Tree::get_if_lambda() const { return std::get_if<Lambda>(&data->data); }
	
	Identifier& Tree::get_identifier() & { return std::get<Identifier>(data->data); }
	Identifier const& Tree::get_identifier() const& { return std::get<Identifier>(data->data); }
	Identifier&& Tree::get_identifier() && { return std::move(std::get<Identifier>(data->data)); }
	Identifier* Tree::get_if_identifier() { return std::get_if<Identifier>(&data->data); }
	Identifier const* Tree::get_if_identifier() const { return std::get_if<Identifier>(&data->data); }
	
	Hole& Tree::get_hole() & { return std::get<Hole>(data->data); }
	Hole const& Tree::get_hole() const& { return std::get<Hole>(data->data); }
	Hole&& Tree::get_hole() && { return std::move(std::get<Hole>(data->data)); }
	Hole* Tree::get_if_hole() { return std::get_if<Hole>(&data->data); }
	Hole const* Tree::get_if_hole() const { return std::get_if<Hole>(&data->data); }
	
	Arrow& Tree::get_arrow() & { return std::get<Arrow>(data->data); }
	Arrow const& Tree::get_arrow() const& { return std::get<Arrow>(data->data); }
	Arrow&& Tree::get_arrow() && { return std::move(std::get<Arrow>(data->data)); }
	Arrow* Tree::get_if_arrow() { return std::get_if<Arrow>(&data->data); }
	Arrow const* Tree::get_if_arrow() const { return std::get_if<Arrow>(&data->data); }
	

	template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) & {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier const&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow const&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) const& {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Identifier&& identifier, Hole&& hole, Arrow&& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) && {
		return std::visit(std::forward<Visitor>(visitor), std::move(data->data));
	}


inline std::uint64_t path_segment_of(Tree Apply::* member) {
  if(member == &Apply::lhs) return 0;
  if(member == &Apply::rhs) return 1;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(std::optional<Tree> Lambda::* member) {
  if(member == &Lambda::type) return 1;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(Tree Lambda::* member) {
  if(member == &Lambda::body) return 0;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(Tree Arrow::* member) {
  if(member == &Arrow::domain) return 0;
  if(member == &Arrow::codomain) return 1;
  std::terminate(); //unreachable
}
template<class... Ts>
inline void path_append(expression_parser::path::Path& path, Ts&&... ts) {
  (path.steps.push_back(path_segment_of(ts)) , ...);
}
template<class... Ts>
inline expression_parser::path::Path path_of(Ts&&... ts) {
  expression_parser::path::Path ret;
  path_append(ret, std::forward<Ts>(ts)...);
  return ret;
}

  
  inline Tree& path_step(Tree& in, std::uint64_t step) {
    return in.visit([&]<class T>(T& part) -> Tree& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return *part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Identifier>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Arrow>) {
        switch(step) {
        case 0: return part.domain;
        
        case 1: return part.codomain;
        
        default: std::terminate();
        }
      }
    });
  }
  
  
  inline Tree const& path_step(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T const& part) -> Tree const& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return *part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Identifier>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Arrow>) {
        switch(step) {
        case 0: return part.domain;
        
        case 1: return part.codomain;
        
        default: std::terminate();
        }
      }
    });
  }
  
  
    inline Tree& path_lookup(Tree& in, expression_parser::path::Path const& path) {
      auto* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  
    inline Tree const& path_lookup(Tree const& in, expression_parser::path::Path const& path) {
      auto const* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  namespace match_result {
    
    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
  	};
    template<class Lhs, class Rhs> Apply(Lhs&&, Rhs&&) -> Apply<Lhs, Rhs>;
  	
    template<class Body, class Type, class ArgName>
  	struct Lambda {
  		Body body;
  		Type type;
  		ArgName arg_name;
  	};
    template<class Body, class Type, class ArgName> Lambda(Body&&, Type&&, ArgName&&) -> Lambda<Body, Type, ArgName>;
  	
    template<class Id>
  	struct Identifier {
  		Id id;
  	};
    template<class Id> Identifier(Id&&) -> Identifier<Id>;
  	
  	struct Hole {
  	};
  	
    template<class Domain, class Codomain, class ArgName>
  	struct Arrow {
  		Domain domain;
  		Codomain codomain;
  		ArgName arg_name;
  	};
    template<class Domain, class Codomain, class ArgName> Arrow(Domain&&, Codomain&&, ArgName&&) -> Arrow<Domain, Codomain, ArgName>;
  	
  }
  namespace match {
    struct Any {
      template<class T>
      bool check(T const&) const { return true; }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    struct None {
      template<class T>
      bool check(std::optional<T> const& opt) const { return !opt.has_value(); }
      template<class T>
      auto match(T&& value) { return std::nullopt; }
    };
    template<class Inner>
    struct Some {
      Inner inner;
      template<class T>
      bool check(std::optional<T> const& opt) const { return opt.has_value() && inner.check(*opt); }
      template<class T>
      T match(std::optional<T>&& value) { return std::move(*value); }
      template<class T>
      T& match(std::optional<T>& value) { return *value; }
      template<class T>
      T const& match(std::optional<T> const& value) { return *value; }
    };
    template<class Matcher, class Test>
    struct Filter {
      Matcher matcher;
      Test test;
      template<class T>
      bool check(T const& value) const { return matcher(value) && test(value); }
      template<class T>
      decltype(auto) match(T&& value) const { return matcher(std::forward<T>(value)); }
    };
    template<class Matcher, class Test> Filter(Matcher, Test) -> Filter<Matcher, Test>;
    template<class Test>
    struct Predicate {
      Test test;
      template<class T>
      bool check(T const& value) const { return test(value); }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    template<class Test> Predicate(Test) -> Predicate<Test>;
    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
    template<class Body, class Type>
  	struct Lambda {
  		Body body;
  		Type type;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .arg_name = component.arg_name
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type)),
            .arg_name = std::move(component.arg_name)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .arg_name = component.arg_name
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type> Lambda(Body, Type) -> Lambda<Body, Type>;
  	struct Identifier {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_identifier();
        return match_result::Identifier{
            .id = component.id
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_identifier();
        return match_result::Identifier{
            .id = std::move(component.id)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_identifier();
        return match_result::Identifier{
            .id = component.id
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  	struct Hole {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Domain, class Codomain>
  	struct Arrow {
  		Domain domain;
  		Codomain codomain;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_arrow()) {
          return domain.check(component->domain)
              && codomain.check(component->codomain);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .arg_name = component.arg_name
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(std::move(component.domain)),
            .codomain = codomain.match(std::move(component.codomain)),
            .arg_name = std::move(component.arg_name)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .arg_name = component.arg_name
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Domain, class Codomain> Arrow(Domain, Codomain) -> Arrow<Domain, Codomain>;
  }
  namespace full_match {
    template<class Lhs, class Rhs>
    struct Apply {
      Lhs lhs;
      Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
    template<class Body, class Type, class ArgName>
    struct Lambda {
      Body body;
      Type type;
      ArgName arg_name;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type)
              && arg_name.check(component->arg_name);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .arg_name = arg_name.match(component.arg_name)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type)),
            .arg_name = arg_name.match(std::move(component.arg_name))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .arg_name = arg_name.match(component.arg_name)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type, class ArgName> Lambda(Body, Type, ArgName) -> Lambda<Body, Type, ArgName>;
    template<class Id>
    struct Identifier {
      Id id;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_identifier()) {
          return id.check(component->id);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_identifier();
        return match_result::Identifier{
            .id = id.match(component.id)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_identifier();
        return match_result::Identifier{
            .id = id.match(std::move(component.id))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_identifier();
        return match_result::Identifier{
            .id = id.match(component.id)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Id> Identifier(Id) -> Identifier<Id>;
    struct Hole {
      bool check(Tree const& tree) const {
        return true;
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Domain, class Codomain, class ArgName>
    struct Arrow {
      Domain domain;
      Codomain codomain;
      ArgName arg_name;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_arrow()) {
          return domain.check(component->domain)
              && codomain.check(component->codomain)
              && arg_name.check(component->arg_name);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .arg_name = arg_name.match(component.arg_name)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(std::move(component.domain)),
            .codomain = codomain.match(std::move(component.codomain)),
            .arg_name = arg_name.match(std::move(component.arg_name))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .arg_name = arg_name.match(component.arg_name)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Domain, class Codomain, class ArgName> Arrow(Domain, Codomain, ArgName) -> Arrow<Domain, Codomain, ArgName>;
  }
}




namespace expression_parser::locator {

	struct Apply;
	struct Lambda;
	struct Identifier;
	struct Hole;
	struct Arrow;

	class Tree {
		struct Impl;
		mdb::Indirect<Impl> data;
	public:
		Tree(Apply arg);
		Tree(Lambda arg);
		Tree(Identifier arg);
		Tree(Hole arg);
		Tree(Arrow arg);
		
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		
		Lambda& get_lambda() &;
		Lambda const& get_lambda() const&;
		Lambda&& get_lambda() &&;
		Lambda* get_if_lambda();
		Lambda const* get_if_lambda() const;
		
		Identifier& get_identifier() &;
		Identifier const& get_identifier() const&;
		Identifier&& get_identifier() &&;
		Identifier* get_if_identifier();
		Identifier const* get_if_identifier() const;
		
		Hole& get_hole() &;
		Hole const& get_hole() const&;
		Hole&& get_hole() &&;
		Hole* get_if_hole();
		Hole const* get_if_hole() const;
		
		Arrow& get_arrow() &;
		Arrow const& get_arrow() const&;
		Arrow&& get_arrow() &&;
		Arrow* get_if_arrow();
		Arrow const* get_if_arrow() const;
		
		template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&> >;
})
		decltype(auto) visit(Visitor&&) &;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier const&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow const&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&> >;
})
		decltype(auto) visit(Visitor&&) const&;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Identifier&& identifier, Hole&& hole, Arrow&& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&> >;
})
		decltype(auto) visit(Visitor&&) &&;

	};
	struct Apply {
		Tree lhs;
		Tree rhs;
		std::string_view position;
	};
	struct Lambda {
		Tree body;
		std::optional<Tree> type;
		std::string_view position;
	};
	struct Identifier {
		std::string_view position;
	};
	struct Hole {
		std::string_view position;
	};
	struct Arrow {
		Tree domain;
		Tree codomain;
		std::string_view position;
	};
	

	struct Tree::Impl {
		std::variant<Apply, Lambda, Identifier, Hole, Arrow> data;
	};
	
	Tree::Tree(Apply arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Lambda arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Identifier arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Hole arg):data(mdb::in_place, std::move(arg)) {}
	Tree::Tree(Arrow arg):data(mdb::in_place, std::move(arg)) {}
	
	Apply& Tree::get_apply() & { return std::get<Apply>(data->data); }
	Apply const& Tree::get_apply() const& { return std::get<Apply>(data->data); }
	Apply&& Tree::get_apply() && { return std::move(std::get<Apply>(data->data)); }
	Apply* Tree::get_if_apply() { return std::get_if<Apply>(&data->data); }
	Apply const* Tree::get_if_apply() const { return std::get_if<Apply>(&data->data); }
	
	Lambda& Tree::get_lambda() & { return std::get<Lambda>(data->data); }
	Lambda const& Tree::get_lambda() const& { return std::get<Lambda>(data->data); }
	Lambda&& Tree::get_lambda() && { return std::move(std::get<Lambda>(data->data)); }
	Lambda* Tree::get_if_lambda() { return std::get_if<Lambda>(&data->data); }
	Lambda const* Tree::get_if_lambda() const { return std::get_if<Lambda>(&data->data); }
	
	Identifier& Tree::get_identifier() & { return std::get<Identifier>(data->data); }
	Identifier const& Tree::get_identifier() const& { return std::get<Identifier>(data->data); }
	Identifier&& Tree::get_identifier() && { return std::move(std::get<Identifier>(data->data)); }
	Identifier* Tree::get_if_identifier() { return std::get_if<Identifier>(&data->data); }
	Identifier const* Tree::get_if_identifier() const { return std::get_if<Identifier>(&data->data); }
	
	Hole& Tree::get_hole() & { return std::get<Hole>(data->data); }
	Hole const& Tree::get_hole() const& { return std::get<Hole>(data->data); }
	Hole&& Tree::get_hole() && { return std::move(std::get<Hole>(data->data)); }
	Hole* Tree::get_if_hole() { return std::get_if<Hole>(&data->data); }
	Hole const* Tree::get_if_hole() const { return std::get_if<Hole>(&data->data); }
	
	Arrow& Tree::get_arrow() & { return std::get<Arrow>(data->data); }
	Arrow const& Tree::get_arrow() const& { return std::get<Arrow>(data->data); }
	Arrow&& Tree::get_arrow() && { return std::move(std::get<Arrow>(data->data)); }
	Arrow* Tree::get_if_arrow() { return std::get_if<Arrow>(&data->data); }
	Arrow const* Tree::get_if_arrow() const { return std::get_if<Arrow>(&data->data); }
	

	template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) & {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda const&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier const&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole const&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow const&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) const& {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, Lambda&& lambda, Identifier&& identifier, Hole&& hole, Arrow&& arrow) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<Lambda&&>(lambda));
	std::forward<Visitor&&>(visitor)(std::forward<Identifier&&>(identifier));
	std::forward<Visitor&&>(visitor)(std::forward<Hole&&>(hole));
	std::forward<Visitor&&>(visitor)(std::forward<Arrow&&>(arrow));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) && {
		return std::visit(std::forward<Visitor>(visitor), std::move(data->data));
	}


inline std::uint64_t path_segment_of(Tree Apply::* member) {
  if(member == &Apply::lhs) return 0;
  if(member == &Apply::rhs) return 1;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(std::optional<Tree> Lambda::* member) {
  if(member == &Lambda::type) return 1;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(Tree Lambda::* member) {
  if(member == &Lambda::body) return 0;
  std::terminate(); //unreachable
}
inline std::uint64_t path_segment_of(Tree Arrow::* member) {
  if(member == &Arrow::domain) return 0;
  if(member == &Arrow::codomain) return 1;
  std::terminate(); //unreachable
}
template<class... Ts>
inline void path_append(expression_parser::path::Path& path, Ts&&... ts) {
  (path.steps.push_back(path_segment_of(ts)) , ...);
}
template<class... Ts>
inline expression_parser::path::Path path_of(Ts&&... ts) {
  expression_parser::path::Path ret;
  path_append(ret, std::forward<Ts>(ts)...);
  return ret;
}

  
  inline Tree& path_step(Tree& in, std::uint64_t step) {
    return in.visit([&]<class T>(T& part) -> Tree& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return *part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Identifier>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Arrow>) {
        switch(step) {
        case 0: return part.domain;
        
        case 1: return part.codomain;
        
        default: std::terminate();
        }
      }
    });
  }
  
  
  inline Tree const& path_step(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T const& part) -> Tree const& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;
        
        case 1: return part.rhs;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Lambda>) {
        switch(step) {
        case 0: return part.body;
        
        case 1: return *part.type;
        
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Identifier>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Hole>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Arrow>) {
        switch(step) {
        case 0: return part.domain;
        
        case 1: return part.codomain;
        
        default: std::terminate();
        }
      }
    });
  }
  
  
    inline Tree& path_lookup(Tree& in, expression_parser::path::Path const& path) {
      auto* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  
    inline Tree const& path_lookup(Tree const& in, expression_parser::path::Path const& path) {
      auto const* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }
    
  namespace match_result {
    
    template<class Lhs, class Rhs, class Position>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
  		Position position;
  	};
    template<class Lhs, class Rhs, class Position> Apply(Lhs&&, Rhs&&, Position&&) -> Apply<Lhs, Rhs, Position>;
  	
    template<class Body, class Type, class Position>
  	struct Lambda {
  		Body body;
  		Type type;
  		Position position;
  	};
    template<class Body, class Type, class Position> Lambda(Body&&, Type&&, Position&&) -> Lambda<Body, Type, Position>;
  	
    template<class Position>
  	struct Identifier {
  		Position position;
  	};
    template<class Position> Identifier(Position&&) -> Identifier<Position>;
  	
    template<class Position>
  	struct Hole {
  		Position position;
  	};
    template<class Position> Hole(Position&&) -> Hole<Position>;
  	
    template<class Domain, class Codomain, class Position>
  	struct Arrow {
  		Domain domain;
  		Codomain codomain;
  		Position position;
  	};
    template<class Domain, class Codomain, class Position> Arrow(Domain&&, Codomain&&, Position&&) -> Arrow<Domain, Codomain, Position>;
  	
  }
  namespace match {
    struct Any {
      template<class T>
      bool check(T const&) const { return true; }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    struct None {
      template<class T>
      bool check(std::optional<T> const& opt) const { return !opt.has_value(); }
      template<class T>
      auto match(T&& value) { return std::nullopt; }
    };
    template<class Inner>
    struct Some {
      Inner inner;
      template<class T>
      bool check(std::optional<T> const& opt) const { return opt.has_value() && inner.check(*opt); }
      template<class T>
      T match(std::optional<T>&& value) { return std::move(*value); }
      template<class T>
      T& match(std::optional<T>& value) { return *value; }
      template<class T>
      T const& match(std::optional<T> const& value) { return *value; }
    };
    template<class Matcher, class Test>
    struct Filter {
      Matcher matcher;
      Test test;
      template<class T>
      bool check(T const& value) const { return matcher(value) && test(value); }
      template<class T>
      decltype(auto) match(T&& value) const { return matcher(std::forward<T>(value)); }
    };
    template<class Matcher, class Test> Filter(Matcher, Test) -> Filter<Matcher, Test>;
    template<class Test>
    struct Predicate {
      Test test;
      template<class T>
      bool check(T const& value) const { return test(value); }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    template<class Test> Predicate(Test) -> Predicate<Test>;
    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .position = component.position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs)),
            .position = std::move(component.position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .position = component.position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
    template<class Body, class Type>
  	struct Lambda {
  		Body body;
  		Type type;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .position = component.position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type)),
            .position = std::move(component.position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .position = component.position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type> Lambda(Body, Type) -> Lambda<Body, Type>;
  	struct Identifier {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_identifier();
        return match_result::Identifier{
            .position = component.position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_identifier();
        return match_result::Identifier{
            .position = std::move(component.position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_identifier();
        return match_result::Identifier{
            .position = component.position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  	struct Hole {
      bool check(Tree const& tree) const {
        return true;
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
            .position = component.position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
            .position = std::move(component.position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
            .position = component.position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Domain, class Codomain>
  	struct Arrow {
  		Domain domain;
  		Codomain codomain;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_arrow()) {
          return domain.check(component->domain)
              && codomain.check(component->codomain);
        } else {
          return false;
        }
        
      }
      auto match(Tree& tree) const {
        auto& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .position = component.position
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(std::move(component.domain)),
            .codomain = codomain.match(std::move(component.codomain)),
            .position = std::move(component.position)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .position = component.position
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Domain, class Codomain> Arrow(Domain, Codomain) -> Arrow<Domain, Codomain>;
  }
  namespace full_match {
    template<class Lhs, class Rhs, class Position>
    struct Apply {
      Lhs lhs;
      Rhs rhs;
      Position position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs)
              && position.check(component->position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs)),
            .position = position.match(std::move(component.position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs),
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs, class Position> Apply(Lhs, Rhs, Position) -> Apply<Lhs, Rhs, Position>;
    template<class Body, class Type, class Position>
    struct Lambda {
      Body body;
      Type type;
      Position position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_lambda()) {
          return body.check(component->body)
              && type.check(component->type)
              && position.check(component->position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(std::move(component.body)),
            .type = type.match(std::move(component.type)),
            .position = position.match(std::move(component.position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_lambda();
        return match_result::Lambda{
            .body = body.match(component.body),
            .type = type.match(component.type),
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Body, class Type, class Position> Lambda(Body, Type, Position) -> Lambda<Body, Type, Position>;
    template<class Position>
    struct Identifier {
      Position position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_identifier()) {
          return position.check(component->position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_identifier();
        return match_result::Identifier{
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_identifier();
        return match_result::Identifier{
            .position = position.match(std::move(component.position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_identifier();
        return match_result::Identifier{
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Position> Identifier(Position) -> Identifier<Position>;
    template<class Position>
    struct Hole {
      Position position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_hole()) {
          return position.check(component->position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_hole();
        return match_result::Hole{
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_hole();
        return match_result::Hole{
            .position = position.match(std::move(component.position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_hole();
        return match_result::Hole{
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Position> Hole(Position) -> Hole<Position>;
    template<class Domain, class Codomain, class Position>
    struct Arrow {
      Domain domain;
      Codomain codomain;
      Position position;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_arrow()) {
          return domain.check(component->domain)
              && codomain.check(component->codomain)
              && position.check(component->position);
        } else {
          return false;
        }
        
      }
    
      auto match(Tree& tree) const {
        auto& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree&& tree) const {
        auto&& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(std::move(component.domain)),
            .codomain = codomain.match(std::move(component.codomain)),
            .position = position.match(std::move(component.position))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    
      auto match(Tree const& tree) const {
        auto const& component = tree.get_arrow();
        return match_result::Arrow{
            .domain = domain.match(component.domain),
            .codomain = codomain.match(component.codomain),
            .position = position.match(component.position)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Domain, class Codomain, class Position> Arrow(Domain, Codomain, Position) -> Arrow<Domain, Codomain, Position>;
  }
}


namespace expression_parser::located_output {
  struct Apply;
  struct Lambda;
  struct Identifier;
  struct Hole;
  struct Arrow;

	struct Tree {
    expression_parser::output::Tree output;
    expression_parser::locator::Tree locator;
		Tree(Apply arg);
		Tree(Lambda arg);
		Tree(Identifier arg);
		Tree(Hole arg);
		Tree(Arrow arg);
	};
	struct Apply {
		Tree lhs;
		Tree rhs;
    std::string_view position;
	};
	struct Lambda {
		Tree body;
		std::optional<Tree> type;
    std::optional<std::string_view> arg_name;
    std::string_view position;
	};
	struct Identifier {
    std::string_view id;
    std::string_view position;
	};
	struct Hole {
    std::string_view position;
	};
	struct Arrow {
		Tree domain;
		Tree codomain;
    std::optional<std::string_view> arg_name;
    std::string_view position;
	};

  Tree::Tree(Apply arg):
    output([&]() -> expression_parser::output::Tree {
      return expression_parser::output::Apply{
        .lhs = std::move(arg.lhs.output),
        .rhs = std::move(arg.rhs.output)
      };
    }()),
    locator([&]() -> expression_parser::locator::Tree {
      return expression_parser::locator::Apply{
        .lhs = std::move(arg.lhs.locator),
        .rhs = std::move(arg.rhs.locator),
        .position = std::move(arg.position)
      };
    }())
  {}
  Tree::Tree(Lambda arg):
    output([&]() -> expression_parser::output::Tree {
      return expression_parser::output::Lambda{
        .body = std::move(arg.body.output),
        .type = [&]() -> std::optional<expression_parser::output::Tree> {
          if(arg.type) {
            return std::move(arg.type->output);
          } else {
            return std::nullopt;
          }
        }(),
        .arg_name = std::move(arg.arg_name)
      };
    }()),
    locator([&]() -> expression_parser::locator::Tree {
      return expression_parser::locator::Lambda{
        .body = std::move(arg.body.locator),
        .type = [&]() -> std::optional<expression_parser::locator::Tree> {
          if(arg.type) {
            return std::move(arg.type->locator);
          } else {
            return std::nullopt;
          }
        }(),
        .position = std::move(arg.position)
      };
    }())
  {}
  Tree::Tree(Identifier arg):
    output([&]() -> expression_parser::output::Tree {
      return expression_parser::output::Identifier{
        .id = std::move(arg.id)
      };
    }()),
    locator([&]() -> expression_parser::locator::Tree {
      return expression_parser::locator::Identifier{
        .position = std::move(arg.position)
      };
    }())
  {}
  Tree::Tree(Hole arg):
    output([&]() -> expression_parser::output::Tree {
      return expression_parser::output::Hole{
      };
    }()),
    locator([&]() -> expression_parser::locator::Tree {
      return expression_parser::locator::Hole{
        .position = std::move(arg.position)
      };
    }())
  {}
  Tree::Tree(Arrow arg):
    output([&]() -> expression_parser::output::Tree {
      return expression_parser::output::Arrow{
        .domain = std::move(arg.domain.output),
        .codomain = std::move(arg.codomain.output),
        .arg_name = std::move(arg.arg_name)
      };
    }()),
    locator([&]() -> expression_parser::locator::Tree {
      return expression_parser::locator::Arrow{
        .domain = std::move(arg.domain.locator),
        .codomain = std::move(arg.codomain.locator),
        .position = std::move(arg.position)
      };
    }())
  {}
}

