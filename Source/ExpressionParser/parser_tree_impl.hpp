#ifndef FILE_SOURCE_EXPRESSION_PARSER_PARSER_TREE_IMPL_HPP
#define FILE_SOURCE_EXPRESSION_PARSER_PARSER_TREE_IMPL_HPP
#include "literals.hpp"
/*
This file is automatically generated! Edits made to it will be overwritten.
The contents of this file are generated from:
  Specification: Source/ExpressionParser/parser_tree.py
  Generator: /home/milo/Documents/Programming/TypeTheory4/Tools/source_generator.py
*/
#include "../Utility/indirect.hpp"
#include "../Utility/overloaded.hpp"
#include <variant>
#include <type_traits>
#include <vector>
#include <optional>
#include <cstdint>
#include <iostream>
#include <string>
#include <span>
#include <memory>
namespace expression_parser::output{
	struct Apply;
	struct Lambda;
	struct Identifier;
	struct Hole;
	struct Arrow;
	struct Block;
	struct Literal;
	struct PatternApply;
	struct PatternIdentifier;
	struct PatternHole;
	struct Declare;
	struct Rule;
	struct Axiom;
	struct Let;
	template<class Visitor> concept ExpressionVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
	};
	template<class Visitor> concept ExpressionConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
	};
	template<class Visitor> concept ExpressionMoveVisitor = requires(Visitor visitor, Apply&& apply, Lambda&& lambda, Identifier&& identifier, Hole&& hole, Arrow&& arrow, Block&& block, Literal&& literal) {
		std::forward<Visitor>(visitor)(std::move(apply));
		std::forward<Visitor>(visitor)(std::move(lambda));
		std::forward<Visitor>(visitor)(std::move(identifier));
		std::forward<Visitor>(visitor)(std::move(hole));
		std::forward<Visitor>(visitor)(std::move(arrow));
		std::forward<Visitor>(visitor)(std::move(block));
		std::forward<Visitor>(visitor)(std::move(literal));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> >;
	};
	class Expression {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Expression(Apply arg);
		Expression(Lambda arg);
		Expression(Identifier arg);
		Expression(Hole arg);
		Expression(Arrow arg);
		Expression(Block arg);
		Expression(Literal arg);
		Expression(Expression const&);
		Expression(Expression&&);
		Expression& operator=(Expression const&);
		Expression& operator=(Expression&&);
		~Expression();
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		bool holds_apply() const;
		Lambda& get_lambda() &;
		Lambda const& get_lambda() const&;
		Lambda&& get_lambda() &&;
		Lambda* get_if_lambda();
		Lambda const* get_if_lambda() const;
		bool holds_lambda() const;
		Identifier& get_identifier() &;
		Identifier const& get_identifier() const&;
		Identifier&& get_identifier() &&;
		Identifier* get_if_identifier();
		Identifier const* get_if_identifier() const;
		bool holds_identifier() const;
		Hole& get_hole() &;
		Hole const& get_hole() const&;
		Hole&& get_hole() &&;
		Hole* get_if_hole();
		Hole const* get_if_hole() const;
		bool holds_hole() const;
		Arrow& get_arrow() &;
		Arrow const& get_arrow() const&;
		Arrow&& get_arrow() &&;
		Arrow* get_if_arrow();
		Arrow const* get_if_arrow() const;
		bool holds_arrow() const;
		Block& get_block() &;
		Block const& get_block() const&;
		Block&& get_block() &&;
		Block* get_if_block();
		Block const* get_if_block() const;
		bool holds_block() const;
		Literal& get_literal() &;
		Literal const& get_literal() const&;
		Literal&& get_literal() &&;
		Literal* get_if_literal();
		Literal const* get_if_literal() const;
		bool holds_literal() const;
		template<ExpressionVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
		template<ExpressionConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
		template<ExpressionMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> >;
	};
	template<class Visitor> concept PatternVisitor = requires(Visitor visitor, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
	};
	template<class Visitor> concept PatternConstVisitor = requires(Visitor visitor, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
	};
	template<class Visitor> concept PatternMoveVisitor = requires(Visitor visitor, PatternApply&& pattern_apply, PatternIdentifier&& pattern_identifier, PatternHole&& pattern_hole) {
		std::forward<Visitor>(visitor)(std::move(pattern_apply));
		std::forward<Visitor>(visitor)(std::move(pattern_identifier));
		std::forward<Visitor>(visitor)(std::move(pattern_hole));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> >;
	};
	class Pattern {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Pattern(PatternApply arg);
		Pattern(PatternIdentifier arg);
		Pattern(PatternHole arg);
		Pattern(Pattern const&);
		Pattern(Pattern&&);
		Pattern& operator=(Pattern const&);
		Pattern& operator=(Pattern&&);
		~Pattern();
		PatternApply& get_pattern_apply() &;
		PatternApply const& get_pattern_apply() const&;
		PatternApply&& get_pattern_apply() &&;
		PatternApply* get_if_pattern_apply();
		PatternApply const* get_if_pattern_apply() const;
		bool holds_pattern_apply() const;
		PatternIdentifier& get_pattern_identifier() &;
		PatternIdentifier const& get_pattern_identifier() const&;
		PatternIdentifier&& get_pattern_identifier() &&;
		PatternIdentifier* get_if_pattern_identifier();
		PatternIdentifier const* get_if_pattern_identifier() const;
		bool holds_pattern_identifier() const;
		PatternHole& get_pattern_hole() &;
		PatternHole const& get_pattern_hole() const&;
		PatternHole&& get_pattern_hole() &&;
		PatternHole* get_if_pattern_hole();
		PatternHole const* get_if_pattern_hole() const;
		bool holds_pattern_hole() const;
		template<PatternVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
		template<PatternConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
		template<PatternMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> >;
	};
	template<class Visitor> concept CommandVisitor = requires(Visitor visitor, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
	template<class Visitor> concept CommandConstVisitor = requires(Visitor visitor, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
	template<class Visitor> concept CommandMoveVisitor = requires(Visitor visitor, Declare&& declare, Rule&& rule, Axiom&& axiom, Let&& let) {
		std::forward<Visitor>(visitor)(std::move(declare));
		std::forward<Visitor>(visitor)(std::move(rule));
		std::forward<Visitor>(visitor)(std::move(axiom));
		std::forward<Visitor>(visitor)(std::move(let));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> >;
	};
	class Command {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Command(Declare arg);
		Command(Rule arg);
		Command(Axiom arg);
		Command(Let arg);
		Command(Command const&);
		Command(Command&&);
		Command& operator=(Command const&);
		Command& operator=(Command&&);
		~Command();
		Declare& get_declare() &;
		Declare const& get_declare() const&;
		Declare&& get_declare() &&;
		Declare* get_if_declare();
		Declare const* get_if_declare() const;
		bool holds_declare() const;
		Rule& get_rule() &;
		Rule const& get_rule() const&;
		Rule&& get_rule() &&;
		Rule* get_if_rule();
		Rule const* get_if_rule() const;
		bool holds_rule() const;
		Axiom& get_axiom() &;
		Axiom const& get_axiom() const&;
		Axiom&& get_axiom() &&;
		Axiom* get_if_axiom();
		Axiom const* get_if_axiom() const;
		bool holds_axiom() const;
		Let& get_let() &;
		Let const& get_let() const&;
		Let&& get_let() &&;
		Let* get_if_let();
		Let const* get_if_let() const;
		bool holds_let() const;
		template<CommandVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
		template<CommandConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
		template<CommandMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> >;
	};
	struct Apply {
		Expression lhs;
		Expression rhs;
	};
	struct Lambda {
		Expression body;
		std::optional<Expression> type;
		std::optional<std::string_view> arg_name;
	};
	struct Identifier {
		std::string_view id;
	};
	struct Hole {
	};
	struct Arrow {
		Expression domain;
		Expression codomain;
		std::optional<std::string_view> arg_name;
	};
	struct Block {
		std::vector<Command> statements;
		Expression value;
	};
	struct Literal {
		literal::Any value;
	};
	struct PatternApply {
		Pattern lhs;
		Pattern rhs;
	};
	struct PatternIdentifier {
		std::string_view id;
	};
	struct PatternHole {
	};
	struct Declare {
		Expression type;
		std::string_view name;
	};
	struct Rule {
		Pattern pattern;
		Expression replacement;
	};
	struct Axiom {
		Expression type;
		std::string_view name;
	};
	struct Let {
		Expression value;
		std::optional<Expression> type;
		std::string_view name;
	};
	template<ExpressionVisitor Visitor> auto Expression::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Lambda*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Identifier*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Hole*)data);
			case 4: return std::forward<Visitor>(visitor)(*(Arrow*)data);
			case 5: return std::forward<Visitor>(visitor)(*(Block*)data);
			case 6: return std::forward<Visitor>(visitor)(*(Literal*)data);
			default: std::terminate();
		}
	}
	template<ExpressionConstVisitor Visitor> auto Expression::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Lambda const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Identifier const*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Hole const*)data);
			case 4: return std::forward<Visitor>(visitor)(*(Arrow const*)data);
			case 5: return std::forward<Visitor>(visitor)(*(Block const*)data);
			case 6: return std::forward<Visitor>(visitor)(*(Literal const*)data);
			default: std::terminate();
		}
	}
	template<ExpressionMoveVisitor Visitor> auto Expression::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Apply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Lambda*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(Identifier*)data));
			case 3: return std::forward<Visitor>(visitor)(std::move(*(Hole*)data));
			case 4: return std::forward<Visitor>(visitor)(std::move(*(Arrow*)data));
			case 5: return std::forward<Visitor>(visitor)(std::move(*(Block*)data));
			case 6: return std::forward<Visitor>(visitor)(std::move(*(Literal*)data));
			default: std::terminate();
		}
	}
	template<PatternVisitor Visitor> auto Pattern::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(PatternApply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(PatternIdentifier*)data);
			case 2: return std::forward<Visitor>(visitor)(*(PatternHole*)data);
			default: std::terminate();
		}
	}
	template<PatternConstVisitor Visitor> auto Pattern::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(PatternApply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(PatternIdentifier const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(PatternHole const*)data);
			default: std::terminate();
		}
	}
	template<PatternMoveVisitor Visitor> auto Pattern::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(PatternApply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(PatternIdentifier*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(PatternHole*)data));
			default: std::terminate();
		}
	}
	template<CommandVisitor Visitor> auto Command::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Declare*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Rule*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Axiom*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Let*)data);
			default: std::terminate();
		}
	}
	template<CommandConstVisitor Visitor> auto Command::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Declare const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Rule const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Axiom const*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Let const*)data);
			default: std::terminate();
		}
	}
	template<CommandMoveVisitor Visitor> auto Command::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Declare*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Rule*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(Axiom*)data));
			case 3: return std::forward<Visitor>(visitor)(std::move(*(Let*)data));
			default: std::terminate();
		}
	}
	bool operator==(Expression const&, Expression const&);
	bool operator==(Pattern const&, Pattern const&);
	bool operator==(Command const&, Command const&);
	bool operator==(Apply const&, Apply const&);
	bool operator==(Lambda const&, Lambda const&);
	bool operator==(Identifier const&, Identifier const&);
	bool operator==(Hole const&, Hole const&);
	bool operator==(Arrow const&, Arrow const&);
	bool operator==(Block const&, Block const&);
	bool operator==(Literal const&, Literal const&);
	bool operator==(PatternApply const&, PatternApply const&);
	bool operator==(PatternIdentifier const&, PatternIdentifier const&);
	bool operator==(PatternHole const&, PatternHole const&);
	bool operator==(Declare const&, Declare const&);
	bool operator==(Rule const&, Rule const&);
	bool operator==(Axiom const&, Axiom const&);
	bool operator==(Let const&, Let const&);
}
namespace expression_parser::locator{
	struct Apply;
	struct Lambda;
	struct Identifier;
	struct Hole;
	struct Arrow;
	struct Block;
	struct Literal;
	struct PatternApply;
	struct PatternIdentifier;
	struct PatternHole;
	struct Declare;
	struct Rule;
	struct Axiom;
	struct Let;
	template<class Visitor> concept ExpressionVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
	};
	template<class Visitor> concept ExpressionConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
	};
	template<class Visitor> concept ExpressionMoveVisitor = requires(Visitor visitor, Apply&& apply, Lambda&& lambda, Identifier&& identifier, Hole&& hole, Arrow&& arrow, Block&& block, Literal&& literal) {
		std::forward<Visitor>(visitor)(std::move(apply));
		std::forward<Visitor>(visitor)(std::move(lambda));
		std::forward<Visitor>(visitor)(std::move(identifier));
		std::forward<Visitor>(visitor)(std::move(hole));
		std::forward<Visitor>(visitor)(std::move(arrow));
		std::forward<Visitor>(visitor)(std::move(block));
		std::forward<Visitor>(visitor)(std::move(literal));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> >;
	};
	class Expression {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Expression(Apply arg);
		Expression(Lambda arg);
		Expression(Identifier arg);
		Expression(Hole arg);
		Expression(Arrow arg);
		Expression(Block arg);
		Expression(Literal arg);
		Expression(Expression const&);
		Expression(Expression&&);
		Expression& operator=(Expression const&);
		Expression& operator=(Expression&&);
		~Expression();
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		bool holds_apply() const;
		Lambda& get_lambda() &;
		Lambda const& get_lambda() const&;
		Lambda&& get_lambda() &&;
		Lambda* get_if_lambda();
		Lambda const* get_if_lambda() const;
		bool holds_lambda() const;
		Identifier& get_identifier() &;
		Identifier const& get_identifier() const&;
		Identifier&& get_identifier() &&;
		Identifier* get_if_identifier();
		Identifier const* get_if_identifier() const;
		bool holds_identifier() const;
		Hole& get_hole() &;
		Hole const& get_hole() const&;
		Hole&& get_hole() &&;
		Hole* get_if_hole();
		Hole const* get_if_hole() const;
		bool holds_hole() const;
		Arrow& get_arrow() &;
		Arrow const& get_arrow() const&;
		Arrow&& get_arrow() &&;
		Arrow* get_if_arrow();
		Arrow const* get_if_arrow() const;
		bool holds_arrow() const;
		Block& get_block() &;
		Block const& get_block() const&;
		Block&& get_block() &&;
		Block* get_if_block();
		Block const* get_if_block() const;
		bool holds_block() const;
		Literal& get_literal() &;
		Literal const& get_literal() const&;
		Literal&& get_literal() &&;
		Literal* get_if_literal();
		Literal const* get_if_literal() const;
		bool holds_literal() const;
		template<ExpressionVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
		template<ExpressionConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
		template<ExpressionMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> >;
	};
	template<class Visitor> concept PatternVisitor = requires(Visitor visitor, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
	};
	template<class Visitor> concept PatternConstVisitor = requires(Visitor visitor, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
	};
	template<class Visitor> concept PatternMoveVisitor = requires(Visitor visitor, PatternApply&& pattern_apply, PatternIdentifier&& pattern_identifier, PatternHole&& pattern_hole) {
		std::forward<Visitor>(visitor)(std::move(pattern_apply));
		std::forward<Visitor>(visitor)(std::move(pattern_identifier));
		std::forward<Visitor>(visitor)(std::move(pattern_hole));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> >;
	};
	class Pattern {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Pattern(PatternApply arg);
		Pattern(PatternIdentifier arg);
		Pattern(PatternHole arg);
		Pattern(Pattern const&);
		Pattern(Pattern&&);
		Pattern& operator=(Pattern const&);
		Pattern& operator=(Pattern&&);
		~Pattern();
		PatternApply& get_pattern_apply() &;
		PatternApply const& get_pattern_apply() const&;
		PatternApply&& get_pattern_apply() &&;
		PatternApply* get_if_pattern_apply();
		PatternApply const* get_if_pattern_apply() const;
		bool holds_pattern_apply() const;
		PatternIdentifier& get_pattern_identifier() &;
		PatternIdentifier const& get_pattern_identifier() const&;
		PatternIdentifier&& get_pattern_identifier() &&;
		PatternIdentifier* get_if_pattern_identifier();
		PatternIdentifier const* get_if_pattern_identifier() const;
		bool holds_pattern_identifier() const;
		PatternHole& get_pattern_hole() &;
		PatternHole const& get_pattern_hole() const&;
		PatternHole&& get_pattern_hole() &&;
		PatternHole* get_if_pattern_hole();
		PatternHole const* get_if_pattern_hole() const;
		bool holds_pattern_hole() const;
		template<PatternVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
		template<PatternConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
		template<PatternMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> >;
	};
	template<class Visitor> concept CommandVisitor = requires(Visitor visitor, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
	template<class Visitor> concept CommandConstVisitor = requires(Visitor visitor, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
	template<class Visitor> concept CommandMoveVisitor = requires(Visitor visitor, Declare&& declare, Rule&& rule, Axiom&& axiom, Let&& let) {
		std::forward<Visitor>(visitor)(std::move(declare));
		std::forward<Visitor>(visitor)(std::move(rule));
		std::forward<Visitor>(visitor)(std::move(axiom));
		std::forward<Visitor>(visitor)(std::move(let));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> >;
	};
	class Command {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Command(Declare arg);
		Command(Rule arg);
		Command(Axiom arg);
		Command(Let arg);
		Command(Command const&);
		Command(Command&&);
		Command& operator=(Command const&);
		Command& operator=(Command&&);
		~Command();
		Declare& get_declare() &;
		Declare const& get_declare() const&;
		Declare&& get_declare() &&;
		Declare* get_if_declare();
		Declare const* get_if_declare() const;
		bool holds_declare() const;
		Rule& get_rule() &;
		Rule const& get_rule() const&;
		Rule&& get_rule() &&;
		Rule* get_if_rule();
		Rule const* get_if_rule() const;
		bool holds_rule() const;
		Axiom& get_axiom() &;
		Axiom const& get_axiom() const&;
		Axiom&& get_axiom() &&;
		Axiom* get_if_axiom();
		Axiom const* get_if_axiom() const;
		bool holds_axiom() const;
		Let& get_let() &;
		Let const& get_let() const&;
		Let&& get_let() &&;
		Let* get_if_let();
		Let const* get_if_let() const;
		bool holds_let() const;
		template<CommandVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
		template<CommandConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
		template<CommandMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> >;
	};
	struct Apply {
		Expression lhs;
		Expression rhs;
		std::string_view position;
	};
	struct Lambda {
		Expression body;
		std::optional<Expression> type;
		std::string_view position;
	};
	struct Identifier {
		std::string_view position;
	};
	struct Hole {
		std::string_view position;
	};
	struct Arrow {
		Expression domain;
		Expression codomain;
		std::string_view position;
	};
	struct Block {
		std::vector<Command> statements;
		Expression value;
		std::string_view position;
	};
	struct Literal {
		std::string_view position;
	};
	struct PatternApply {
		Pattern lhs;
		Pattern rhs;
		std::string_view position;
	};
	struct PatternIdentifier {
		std::string_view position;
	};
	struct PatternHole {
		std::string_view position;
	};
	struct Declare {
		Expression type;
		std::string_view position;
	};
	struct Rule {
		Pattern pattern;
		Expression replacement;
		std::string_view position;
	};
	struct Axiom {
		Expression type;
		std::string_view position;
	};
	struct Let {
		Expression value;
		std::optional<Expression> type;
		std::string_view position;
	};
	template<ExpressionVisitor Visitor> auto Expression::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Lambda*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Identifier*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Hole*)data);
			case 4: return std::forward<Visitor>(visitor)(*(Arrow*)data);
			case 5: return std::forward<Visitor>(visitor)(*(Block*)data);
			case 6: return std::forward<Visitor>(visitor)(*(Literal*)data);
			default: std::terminate();
		}
	}
	template<ExpressionConstVisitor Visitor> auto Expression::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Lambda const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Identifier const*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Hole const*)data);
			case 4: return std::forward<Visitor>(visitor)(*(Arrow const*)data);
			case 5: return std::forward<Visitor>(visitor)(*(Block const*)data);
			case 6: return std::forward<Visitor>(visitor)(*(Literal const*)data);
			default: std::terminate();
		}
	}
	template<ExpressionMoveVisitor Visitor> auto Expression::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Apply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Lambda*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(Identifier*)data));
			case 3: return std::forward<Visitor>(visitor)(std::move(*(Hole*)data));
			case 4: return std::forward<Visitor>(visitor)(std::move(*(Arrow*)data));
			case 5: return std::forward<Visitor>(visitor)(std::move(*(Block*)data));
			case 6: return std::forward<Visitor>(visitor)(std::move(*(Literal*)data));
			default: std::terminate();
		}
	}
	template<PatternVisitor Visitor> auto Pattern::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(PatternApply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(PatternIdentifier*)data);
			case 2: return std::forward<Visitor>(visitor)(*(PatternHole*)data);
			default: std::terminate();
		}
	}
	template<PatternConstVisitor Visitor> auto Pattern::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(PatternApply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(PatternIdentifier const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(PatternHole const*)data);
			default: std::terminate();
		}
	}
	template<PatternMoveVisitor Visitor> auto Pattern::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(PatternApply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(PatternIdentifier*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(PatternHole*)data));
			default: std::terminate();
		}
	}
	template<CommandVisitor Visitor> auto Command::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Declare*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Rule*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Axiom*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Let*)data);
			default: std::terminate();
		}
	}
	template<CommandConstVisitor Visitor> auto Command::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Declare const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Rule const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Axiom const*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Let const*)data);
			default: std::terminate();
		}
	}
	template<CommandMoveVisitor Visitor> auto Command::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Declare*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Rule*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(Axiom*)data));
			case 3: return std::forward<Visitor>(visitor)(std::move(*(Let*)data));
			default: std::terminate();
		}
	}
	bool operator==(Expression const&, Expression const&);
	bool operator==(Pattern const&, Pattern const&);
	bool operator==(Command const&, Command const&);
	bool operator==(Apply const&, Apply const&);
	bool operator==(Lambda const&, Lambda const&);
	bool operator==(Identifier const&, Identifier const&);
	bool operator==(Hole const&, Hole const&);
	bool operator==(Arrow const&, Arrow const&);
	bool operator==(Block const&, Block const&);
	bool operator==(Literal const&, Literal const&);
	bool operator==(PatternApply const&, PatternApply const&);
	bool operator==(PatternIdentifier const&, PatternIdentifier const&);
	bool operator==(PatternHole const&, PatternHole const&);
	bool operator==(Declare const&, Declare const&);
	bool operator==(Rule const&, Rule const&);
	bool operator==(Axiom const&, Axiom const&);
	bool operator==(Let const&, Let const&);
}
namespace expression_parser::resolved{
	struct Apply;
	struct Lambda;
	struct Identifier;
	struct Hole;
	struct Arrow;
	struct Block;
	struct Literal;
	struct PatternApply;
	struct PatternIdentifier;
	struct PatternHole;
	struct Declare;
	struct Rule;
	struct Axiom;
	struct Let;
	template<class Visitor> concept ExpressionVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
	};
	template<class Visitor> concept ExpressionConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
	};
	template<class Visitor> concept ExpressionMoveVisitor = requires(Visitor visitor, Apply&& apply, Lambda&& lambda, Identifier&& identifier, Hole&& hole, Arrow&& arrow, Block&& block, Literal&& literal) {
		std::forward<Visitor>(visitor)(std::move(apply));
		std::forward<Visitor>(visitor)(std::move(lambda));
		std::forward<Visitor>(visitor)(std::move(identifier));
		std::forward<Visitor>(visitor)(std::move(hole));
		std::forward<Visitor>(visitor)(std::move(arrow));
		std::forward<Visitor>(visitor)(std::move(block));
		std::forward<Visitor>(visitor)(std::move(literal));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> >;
	};
	class Expression {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Expression(Apply arg);
		Expression(Lambda arg);
		Expression(Identifier arg);
		Expression(Hole arg);
		Expression(Arrow arg);
		Expression(Block arg);
		Expression(Literal arg);
		Expression(Expression const&);
		Expression(Expression&&);
		Expression& operator=(Expression const&);
		Expression& operator=(Expression&&);
		~Expression();
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		bool holds_apply() const;
		Lambda& get_lambda() &;
		Lambda const& get_lambda() const&;
		Lambda&& get_lambda() &&;
		Lambda* get_if_lambda();
		Lambda const* get_if_lambda() const;
		bool holds_lambda() const;
		Identifier& get_identifier() &;
		Identifier const& get_identifier() const&;
		Identifier&& get_identifier() &&;
		Identifier* get_if_identifier();
		Identifier const* get_if_identifier() const;
		bool holds_identifier() const;
		Hole& get_hole() &;
		Hole const& get_hole() const&;
		Hole&& get_hole() &&;
		Hole* get_if_hole();
		Hole const* get_if_hole() const;
		bool holds_hole() const;
		Arrow& get_arrow() &;
		Arrow const& get_arrow() const&;
		Arrow&& get_arrow() &&;
		Arrow* get_if_arrow();
		Arrow const* get_if_arrow() const;
		bool holds_arrow() const;
		Block& get_block() &;
		Block const& get_block() const&;
		Block&& get_block() &&;
		Block* get_if_block();
		Block const* get_if_block() const;
		bool holds_block() const;
		Literal& get_literal() &;
		Literal const& get_literal() const&;
		Literal&& get_literal() &&;
		Literal* get_if_literal();
		Literal const* get_if_literal() const;
		bool holds_literal() const;
		template<ExpressionVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
		template<ExpressionConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
		template<ExpressionMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> >;
	};
	template<class Visitor> concept PatternVisitor = requires(Visitor visitor, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
	};
	template<class Visitor> concept PatternConstVisitor = requires(Visitor visitor, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
	};
	template<class Visitor> concept PatternMoveVisitor = requires(Visitor visitor, PatternApply&& pattern_apply, PatternIdentifier&& pattern_identifier, PatternHole&& pattern_hole) {
		std::forward<Visitor>(visitor)(std::move(pattern_apply));
		std::forward<Visitor>(visitor)(std::move(pattern_identifier));
		std::forward<Visitor>(visitor)(std::move(pattern_hole));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> >;
	};
	class Pattern {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Pattern(PatternApply arg);
		Pattern(PatternIdentifier arg);
		Pattern(PatternHole arg);
		Pattern(Pattern const&);
		Pattern(Pattern&&);
		Pattern& operator=(Pattern const&);
		Pattern& operator=(Pattern&&);
		~Pattern();
		PatternApply& get_pattern_apply() &;
		PatternApply const& get_pattern_apply() const&;
		PatternApply&& get_pattern_apply() &&;
		PatternApply* get_if_pattern_apply();
		PatternApply const* get_if_pattern_apply() const;
		bool holds_pattern_apply() const;
		PatternIdentifier& get_pattern_identifier() &;
		PatternIdentifier const& get_pattern_identifier() const&;
		PatternIdentifier&& get_pattern_identifier() &&;
		PatternIdentifier* get_if_pattern_identifier();
		PatternIdentifier const* get_if_pattern_identifier() const;
		bool holds_pattern_identifier() const;
		PatternHole& get_pattern_hole() &;
		PatternHole const& get_pattern_hole() const&;
		PatternHole&& get_pattern_hole() &&;
		PatternHole* get_if_pattern_hole();
		PatternHole const* get_if_pattern_hole() const;
		bool holds_pattern_hole() const;
		template<PatternVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
		template<PatternConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
		template<PatternMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> >;
	};
	template<class Visitor> concept CommandVisitor = requires(Visitor visitor, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
	template<class Visitor> concept CommandConstVisitor = requires(Visitor visitor, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
	template<class Visitor> concept CommandMoveVisitor = requires(Visitor visitor, Declare&& declare, Rule&& rule, Axiom&& axiom, Let&& let) {
		std::forward<Visitor>(visitor)(std::move(declare));
		std::forward<Visitor>(visitor)(std::move(rule));
		std::forward<Visitor>(visitor)(std::move(axiom));
		std::forward<Visitor>(visitor)(std::move(let));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> >;
	};
	class Command {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Command(Declare arg);
		Command(Rule arg);
		Command(Axiom arg);
		Command(Let arg);
		Command(Command const&);
		Command(Command&&);
		Command& operator=(Command const&);
		Command& operator=(Command&&);
		~Command();
		Declare& get_declare() &;
		Declare const& get_declare() const&;
		Declare&& get_declare() &&;
		Declare* get_if_declare();
		Declare const* get_if_declare() const;
		bool holds_declare() const;
		Rule& get_rule() &;
		Rule const& get_rule() const&;
		Rule&& get_rule() &&;
		Rule* get_if_rule();
		Rule const* get_if_rule() const;
		bool holds_rule() const;
		Axiom& get_axiom() &;
		Axiom const& get_axiom() const&;
		Axiom&& get_axiom() &&;
		Axiom* get_if_axiom();
		Axiom const* get_if_axiom() const;
		bool holds_axiom() const;
		Let& get_let() &;
		Let const& get_let() const&;
		Let&& get_let() &&;
		Let* get_if_let();
		Let const* get_if_let() const;
		bool holds_let() const;
		template<CommandVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
		template<CommandConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
		template<CommandMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> >;
	};
	struct Apply {
		Expression lhs;
		Expression rhs;
	};
	struct Lambda {
		Expression body;
		std::optional<Expression> type;
	};
	struct Identifier {
		bool is_local;
		std::uint64_t var_index;
	};
	struct Hole {
	};
	struct Arrow {
		Expression domain;
		Expression codomain;
	};
	struct Block {
		std::vector<Command> statements;
		Expression value;
	};
	struct Literal {
		std::uint64_t embed_index;
	};
	struct PatternApply {
		Pattern lhs;
		Pattern rhs;
	};
	struct PatternIdentifier {
		bool is_local;
		std::uint64_t var_index;
	};
	struct PatternHole {
		std::uint64_t var_index;
	};
	struct Declare {
		Expression type;
	};
	struct Rule {
		Pattern pattern;
		Expression replacement;
		std::uint64_t args_in_pattern;
	};
	struct Axiom {
		Expression type;
	};
	struct Let {
		Expression value;
		std::optional<Expression> type;
	};
	template<ExpressionVisitor Visitor> auto Expression::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Lambda*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Identifier*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Hole*)data);
			case 4: return std::forward<Visitor>(visitor)(*(Arrow*)data);
			case 5: return std::forward<Visitor>(visitor)(*(Block*)data);
			case 6: return std::forward<Visitor>(visitor)(*(Literal*)data);
			default: std::terminate();
		}
	}
	template<ExpressionConstVisitor Visitor> auto Expression::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Lambda const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Identifier const*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Hole const*)data);
			case 4: return std::forward<Visitor>(visitor)(*(Arrow const*)data);
			case 5: return std::forward<Visitor>(visitor)(*(Block const*)data);
			case 6: return std::forward<Visitor>(visitor)(*(Literal const*)data);
			default: std::terminate();
		}
	}
	template<ExpressionMoveVisitor Visitor> auto Expression::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Lambda&&>, std::invoke_result_t<Visitor&&, Identifier&&>, std::invoke_result_t<Visitor&&, Hole&&>, std::invoke_result_t<Visitor&&, Arrow&&>, std::invoke_result_t<Visitor&&, Block&&>, std::invoke_result_t<Visitor&&, Literal&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Apply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Lambda*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(Identifier*)data));
			case 3: return std::forward<Visitor>(visitor)(std::move(*(Hole*)data));
			case 4: return std::forward<Visitor>(visitor)(std::move(*(Arrow*)data));
			case 5: return std::forward<Visitor>(visitor)(std::move(*(Block*)data));
			case 6: return std::forward<Visitor>(visitor)(std::move(*(Literal*)data));
			default: std::terminate();
		}
	}
	template<PatternVisitor Visitor> auto Pattern::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(PatternApply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(PatternIdentifier*)data);
			case 2: return std::forward<Visitor>(visitor)(*(PatternHole*)data);
			default: std::terminate();
		}
	}
	template<PatternConstVisitor Visitor> auto Pattern::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(PatternApply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(PatternIdentifier const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(PatternHole const*)data);
			default: std::terminate();
		}
	}
	template<PatternMoveVisitor Visitor> auto Pattern::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&&>, std::invoke_result_t<Visitor&&, PatternIdentifier&&>, std::invoke_result_t<Visitor&&, PatternHole&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(PatternApply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(PatternIdentifier*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(PatternHole*)data));
			default: std::terminate();
		}
	}
	template<CommandVisitor Visitor> auto Command::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Declare*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Rule*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Axiom*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Let*)data);
			default: std::terminate();
		}
	}
	template<CommandConstVisitor Visitor> auto Command::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Declare const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Rule const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Axiom const*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Let const*)data);
			default: std::terminate();
		}
	}
	template<CommandMoveVisitor Visitor> auto Command::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&&>, std::invoke_result_t<Visitor&&, Rule&&>, std::invoke_result_t<Visitor&&, Axiom&&>, std::invoke_result_t<Visitor&&, Let&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Declare*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Rule*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(Axiom*)data));
			case 3: return std::forward<Visitor>(visitor)(std::move(*(Let*)data));
			default: std::terminate();
		}
	}
	bool operator==(Expression const&, Expression const&);
	bool operator==(Pattern const&, Pattern const&);
	bool operator==(Command const&, Command const&);
	bool operator==(Apply const&, Apply const&);
	bool operator==(Lambda const&, Lambda const&);
	bool operator==(Identifier const&, Identifier const&);
	bool operator==(Hole const&, Hole const&);
	bool operator==(Arrow const&, Arrow const&);
	bool operator==(Block const&, Block const&);
	bool operator==(Literal const&, Literal const&);
	bool operator==(PatternApply const&, PatternApply const&);
	bool operator==(PatternIdentifier const&, PatternIdentifier const&);
	bool operator==(PatternHole const&, PatternHole const&);
	bool operator==(Declare const&, Declare const&);
	bool operator==(Rule const&, Rule const&);
	bool operator==(Axiom const&, Axiom const&);
	bool operator==(Let const&, Let const&);
}
namespace expression_parser::output::archive_part{
    class PolymorphicKind;
    class Expression;
    class Pattern;
    class Command;
    class Apply;
    class Lambda;
    class Identifier;
    class Hole;
    class Arrow;
    class Block;
    class Literal;
    class PatternApply;
    class PatternIdentifier;
    class PatternHole;
    class Declare;
    class Rule;
    class Axiom;
    class Let;
}
namespace expression_parser::locator::archive_part{
    class PolymorphicKind;
    class Expression;
    class Pattern;
    class Command;
    class Apply;
    class Lambda;
    class Identifier;
    class Hole;
    class Arrow;
    class Block;
    class Literal;
    class PatternApply;
    class PatternIdentifier;
    class PatternHole;
    class Declare;
    class Rule;
    class Axiom;
    class Let;
}
namespace expression_parser::resolved::archive_part{
    class PolymorphicKind;
    class Expression;
    class Pattern;
    class Command;
    class Apply;
    class Lambda;
    class Identifier;
    class Hole;
    class Arrow;
    class Block;
    class Literal;
    class PatternApply;
    class PatternIdentifier;
    class PatternHole;
    class Declare;
    class Rule;
    class Axiom;
    class Let;
}
namespace expression_parser::archive_index{
    class Apply {
        std::uint64_t private_index;
        explicit Apply(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Apply;
        friend class expression_parser::locator::archive_part::Apply;
        friend class expression_parser::resolved::archive_part::Apply;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Apply const& lhs, Apply const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Apply const& lhs, Apply const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Lambda {
        std::uint64_t private_index;
        explicit Lambda(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Lambda;
        friend class expression_parser::locator::archive_part::Lambda;
        friend class expression_parser::resolved::archive_part::Lambda;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Lambda const& lhs, Lambda const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Lambda const& lhs, Lambda const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Identifier {
        std::uint64_t private_index;
        explicit Identifier(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Identifier;
        friend class expression_parser::locator::archive_part::Identifier;
        friend class expression_parser::resolved::archive_part::Identifier;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Identifier const& lhs, Identifier const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Identifier const& lhs, Identifier const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Hole {
        std::uint64_t private_index;
        explicit Hole(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Hole;
        friend class expression_parser::locator::archive_part::Hole;
        friend class expression_parser::resolved::archive_part::Hole;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Hole const& lhs, Hole const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Hole const& lhs, Hole const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Arrow {
        std::uint64_t private_index;
        explicit Arrow(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Arrow;
        friend class expression_parser::locator::archive_part::Arrow;
        friend class expression_parser::resolved::archive_part::Arrow;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Arrow const& lhs, Arrow const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Arrow const& lhs, Arrow const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Block {
        std::uint64_t private_index;
        explicit Block(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Block;
        friend class expression_parser::locator::archive_part::Block;
        friend class expression_parser::resolved::archive_part::Block;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Block const& lhs, Block const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Block const& lhs, Block const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Literal {
        std::uint64_t private_index;
        explicit Literal(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Literal;
        friend class expression_parser::locator::archive_part::Literal;
        friend class expression_parser::resolved::archive_part::Literal;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Literal const& lhs, Literal const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Literal const& lhs, Literal const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class PatternApply {
        std::uint64_t private_index;
        explicit PatternApply(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::PatternApply;
        friend class expression_parser::locator::archive_part::PatternApply;
        friend class expression_parser::resolved::archive_part::PatternApply;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(PatternApply const& lhs, PatternApply const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(PatternApply const& lhs, PatternApply const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class PatternIdentifier {
        std::uint64_t private_index;
        explicit PatternIdentifier(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::PatternIdentifier;
        friend class expression_parser::locator::archive_part::PatternIdentifier;
        friend class expression_parser::resolved::archive_part::PatternIdentifier;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(PatternIdentifier const& lhs, PatternIdentifier const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(PatternIdentifier const& lhs, PatternIdentifier const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class PatternHole {
        std::uint64_t private_index;
        explicit PatternHole(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::PatternHole;
        friend class expression_parser::locator::archive_part::PatternHole;
        friend class expression_parser::resolved::archive_part::PatternHole;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(PatternHole const& lhs, PatternHole const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(PatternHole const& lhs, PatternHole const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Declare {
        std::uint64_t private_index;
        explicit Declare(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Declare;
        friend class expression_parser::locator::archive_part::Declare;
        friend class expression_parser::resolved::archive_part::Declare;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Declare const& lhs, Declare const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Declare const& lhs, Declare const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Rule {
        std::uint64_t private_index;
        explicit Rule(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Rule;
        friend class expression_parser::locator::archive_part::Rule;
        friend class expression_parser::resolved::archive_part::Rule;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Rule const& lhs, Rule const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Rule const& lhs, Rule const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Axiom {
        std::uint64_t private_index;
        explicit Axiom(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Axiom;
        friend class expression_parser::locator::archive_part::Axiom;
        friend class expression_parser::resolved::archive_part::Axiom;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Axiom const& lhs, Axiom const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Axiom const& lhs, Axiom const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Let {
        std::uint64_t private_index;
        explicit Let(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Let;
        friend class expression_parser::locator::archive_part::Let;
        friend class expression_parser::resolved::archive_part::Let;
    public:
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Let const& lhs, Let const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Let const& lhs, Let const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Expression {
        std::uint64_t private_index;
        explicit Expression(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Expression;
        friend class expression_parser::locator::archive_part::Expression;
        friend class expression_parser::resolved::archive_part::Expression;
    public:
        Expression(Apply component):private_index(component.index()) {}
        Expression(Lambda component):private_index(component.index()) {}
        Expression(Identifier component):private_index(component.index()) {}
        Expression(Hole component):private_index(component.index()) {}
        Expression(Arrow component):private_index(component.index()) {}
        Expression(Block component):private_index(component.index()) {}
        Expression(Literal component):private_index(component.index()) {}
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Expression const& lhs, Expression const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Expression const& lhs, Expression const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Pattern {
        std::uint64_t private_index;
        explicit Pattern(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Pattern;
        friend class expression_parser::locator::archive_part::Pattern;
        friend class expression_parser::resolved::archive_part::Pattern;
    public:
        Pattern(PatternApply component):private_index(component.index()) {}
        Pattern(PatternIdentifier component):private_index(component.index()) {}
        Pattern(PatternHole component):private_index(component.index()) {}
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Pattern const& lhs, Pattern const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Pattern const& lhs, Pattern const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class Command {
        std::uint64_t private_index;
        explicit Command(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::Command;
        friend class expression_parser::locator::archive_part::Command;
        friend class expression_parser::resolved::archive_part::Command;
    public:
        Command(Declare component):private_index(component.index()) {}
        Command(Rule component):private_index(component.index()) {}
        Command(Axiom component):private_index(component.index()) {}
        Command(Let component):private_index(component.index()) {}
        std::uint64_t index() const { return private_index; }
        friend bool operator==(Command const& lhs, Command const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(Command const& lhs, Command const& rhs) { return lhs.private_index != rhs.private_index; }
    };
    class PolymorphicKind {
        std::uint64_t private_index;
        explicit PolymorphicKind(std::uint64_t private_index):private_index(private_index) {}
        friend class expression_parser::output::archive_part::PolymorphicKind;
        friend class expression_parser::locator::archive_part::PolymorphicKind;
        friend class expression_parser::resolved::archive_part::PolymorphicKind;
    public:
        PolymorphicKind(Apply component):private_index(component.index()) {}
        PolymorphicKind(Lambda component):private_index(component.index()) {}
        PolymorphicKind(Identifier component):private_index(component.index()) {}
        PolymorphicKind(Hole component):private_index(component.index()) {}
        PolymorphicKind(Arrow component):private_index(component.index()) {}
        PolymorphicKind(Block component):private_index(component.index()) {}
        PolymorphicKind(Literal component):private_index(component.index()) {}
        PolymorphicKind(PatternApply component):private_index(component.index()) {}
        PolymorphicKind(PatternIdentifier component):private_index(component.index()) {}
        PolymorphicKind(PatternHole component):private_index(component.index()) {}
        PolymorphicKind(Declare component):private_index(component.index()) {}
        PolymorphicKind(Rule component):private_index(component.index()) {}
        PolymorphicKind(Axiom component):private_index(component.index()) {}
        PolymorphicKind(Let component):private_index(component.index()) {}
        PolymorphicKind(Expression kind):private_index(kind.index()) {}
        PolymorphicKind(Pattern kind):private_index(kind.index()) {}
        PolymorphicKind(Command kind):private_index(kind.index()) {}
        std::uint64_t index() const { return private_index; }
        friend bool operator==(PolymorphicKind const& lhs, PolymorphicKind const& rhs) { return lhs.private_index == rhs.private_index; }
        friend bool operator!=(PolymorphicKind const& lhs, PolymorphicKind const& rhs) { return lhs.private_index != rhs.private_index; }
    };
}
namespace expression_parser::output::archive_detail{
    struct Detail;
    static constexpr std::uint64_t kind_table[] = {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2};
}
namespace expression_parser::output::archive_part{
  template<class Visitor> concept PolymorphicKindVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&>, std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&>, std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
  template<class Visitor> concept PolymorphicKindConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&>, std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&>, std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
  class PolymorphicKind {
    friend expression_parser::output::archive_detail::Detail;
    friend Expression;
    friend Pattern;
    friend Command;
    friend Apply;
    friend Lambda;
    friend Identifier;
    friend Hole;
    friend Arrow;
    friend Block;
    friend Literal;
    friend PatternApply;
    friend PatternIdentifier;
    friend PatternHole;
    friend Declare;
    friend Rule;
    friend Axiom;
    friend Let;
    std::uint64_t const discriminator;
    std::uint64_t const private_index;
    PolymorphicKind(std::uint64_t discriminator, std::uint64_t private_index):discriminator(discriminator),private_index(private_index){}
    ~PolymorphicKind() {}
  public:
    PolymorphicKind(PolymorphicKind const&) = delete;
    PolymorphicKind(PolymorphicKind&&) = delete;
    PolymorphicKind& operator=(PolymorphicKind const&) = delete;
    PolymorphicKind& operator=(PolymorphicKind&&) = delete;
    expression_parser::archive_index::PolymorphicKind index() const { return expression_parser::archive_index::PolymorphicKind{private_index}; }
    Expression& get_expression();
    Expression const& get_expression() const;
    Expression* get_if_expression();
    Expression const* get_if_expression() const;
    Pattern& get_pattern();
    Pattern const& get_pattern() const;
    Pattern* get_if_pattern();
    Pattern const* get_if_pattern() const;
    Command& get_command();
    Command const& get_command() const;
    Command* get_if_command();
    Command const* get_if_command() const;
    Apply& get_apply();
    Apply const& get_apply() const;
    Apply* get_if_apply();
    Apply const* get_if_apply() const;
    Lambda& get_lambda();
    Lambda const& get_lambda() const;
    Lambda* get_if_lambda();
    Lambda const* get_if_lambda() const;
    Identifier& get_identifier();
    Identifier const& get_identifier() const;
    Identifier* get_if_identifier();
    Identifier const* get_if_identifier() const;
    Hole& get_hole();
    Hole const& get_hole() const;
    Hole* get_if_hole();
    Hole const* get_if_hole() const;
    Arrow& get_arrow();
    Arrow const& get_arrow() const;
    Arrow* get_if_arrow();
    Arrow const* get_if_arrow() const;
    Block& get_block();
    Block const& get_block() const;
    Block* get_if_block();
    Block const* get_if_block() const;
    Literal& get_literal();
    Literal const& get_literal() const;
    Literal* get_if_literal();
    Literal const* get_if_literal() const;
    PatternApply& get_pattern_apply();
    PatternApply const& get_pattern_apply() const;
    PatternApply* get_if_pattern_apply();
    PatternApply const* get_if_pattern_apply() const;
    PatternIdentifier& get_pattern_identifier();
    PatternIdentifier const& get_pattern_identifier() const;
    PatternIdentifier* get_if_pattern_identifier();
    PatternIdentifier const* get_if_pattern_identifier() const;
    PatternHole& get_pattern_hole();
    PatternHole const& get_pattern_hole() const;
    PatternHole* get_if_pattern_hole();
    PatternHole const* get_if_pattern_hole() const;
    Declare& get_declare();
    Declare const& get_declare() const;
    Declare* get_if_declare();
    Declare const* get_if_declare() const;
    Rule& get_rule();
    Rule const& get_rule() const;
    Rule* get_if_rule();
    Rule const* get_if_rule() const;
    Axiom& get_axiom();
    Axiom const& get_axiom() const;
    Axiom* get_if_axiom();
    Axiom const* get_if_axiom() const;
    Let& get_let();
    Let const& get_let() const;
    Let* get_if_let();
    Let const* get_if_let() const;
    template<PolymorphicKindVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&>, std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&>, std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
    template<PolymorphicKindConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&>, std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&>, std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
    template<class Visitor> auto visit_kind(Visitor&& visitor);
    template<class Visitor> auto visit_kind(Visitor&& visitor) const;
  };
  template<class Visitor> concept ExpressionVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
	};
  template<class Visitor> concept ExpressionConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
	};
  class Expression : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::output::archive_detail::Detail;
    friend Apply;
    friend Lambda;
    friend Identifier;
    friend Hole;
    friend Arrow;
    friend Block;
    friend Literal;
    Expression(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Expression() {}
  public:
    Expression(Expression const&) = delete;
    Expression(Expression&&) = delete;
    Expression& operator=(Expression const&) = delete;
    Expression& operator=(Expression&&) = delete;
    expression_parser::archive_index::Expression index() const { return expression_parser::archive_index::Expression{private_index}; }
    Apply& get_apply();
    Apply const& get_apply() const;
    Apply* get_if_apply();
    Apply const* get_if_apply() const;
    Lambda& get_lambda();
    Lambda const& get_lambda() const;
    Lambda* get_if_lambda();
    Lambda const* get_if_lambda() const;
    Identifier& get_identifier();
    Identifier const& get_identifier() const;
    Identifier* get_if_identifier();
    Identifier const* get_if_identifier() const;
    Hole& get_hole();
    Hole const& get_hole() const;
    Hole* get_if_hole();
    Hole const* get_if_hole() const;
    Arrow& get_arrow();
    Arrow const& get_arrow() const;
    Arrow* get_if_arrow();
    Arrow const* get_if_arrow() const;
    Block& get_block();
    Block const& get_block() const;
    Block* get_if_block();
    Block const* get_if_block() const;
    Literal& get_literal();
    Literal const& get_literal() const;
    Literal* get_if_literal();
    Literal const* get_if_literal() const;
    template<ExpressionVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
    template<ExpressionConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  class OptionalExpression {
    Expression* ptr;
    OptionalExpression(Expression* ptr):ptr(ptr) {}
    friend Lambda;
    friend Let;
  public:
    OptionalExpression(OptionalExpression const&) = delete;
    OptionalExpression(OptionalExpression&&) = delete;
    OptionalExpression& operator=(OptionalExpression const&) = delete;
    OptionalExpression& operator=(OptionalExpression&&) = delete;
    operator bool() const { return ptr != nullptr; }
    Expression& operator*() { return *ptr; }
    Expression const& operator*() const { return *ptr; }
    Expression* operator->() { return ptr; }
    Expression const* operator->() const { return ptr; }
  };
  template<class Visitor> concept PatternVisitor = requires(Visitor visitor, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
	};
  template<class Visitor> concept PatternConstVisitor = requires(Visitor visitor, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
	};
  class Pattern : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::output::archive_detail::Detail;
    friend PatternApply;
    friend PatternIdentifier;
    friend PatternHole;
    Pattern(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Pattern() {}
  public:
    Pattern(Pattern const&) = delete;
    Pattern(Pattern&&) = delete;
    Pattern& operator=(Pattern const&) = delete;
    Pattern& operator=(Pattern&&) = delete;
    expression_parser::archive_index::Pattern index() const { return expression_parser::archive_index::Pattern{private_index}; }
    PatternApply& get_pattern_apply();
    PatternApply const& get_pattern_apply() const;
    PatternApply* get_if_pattern_apply();
    PatternApply const* get_if_pattern_apply() const;
    PatternIdentifier& get_pattern_identifier();
    PatternIdentifier const& get_pattern_identifier() const;
    PatternIdentifier* get_if_pattern_identifier();
    PatternIdentifier const* get_if_pattern_identifier() const;
    PatternHole& get_pattern_hole();
    PatternHole const& get_pattern_hole() const;
    PatternHole* get_if_pattern_hole();
    PatternHole const* get_if_pattern_hole() const;
    template<PatternVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
    template<PatternConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  template<class Visitor> concept CommandVisitor = requires(Visitor visitor, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
  template<class Visitor> concept CommandConstVisitor = requires(Visitor visitor, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
  class Command : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::output::archive_detail::Detail;
    friend Declare;
    friend Rule;
    friend Axiom;
    friend Let;
    Command(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Command() {}
  public:
    Command(Command const&) = delete;
    Command(Command&&) = delete;
    Command& operator=(Command const&) = delete;
    Command& operator=(Command&&) = delete;
    expression_parser::archive_index::Command index() const { return expression_parser::archive_index::Command{private_index}; }
    Declare& get_declare();
    Declare const& get_declare() const;
    Declare* get_if_declare();
    Declare const* get_if_declare() const;
    Rule& get_rule();
    Rule const& get_rule() const;
    Rule* get_if_rule();
    Rule const* get_if_rule() const;
    Axiom& get_axiom();
    Axiom const& get_axiom() const;
    Axiom* get_if_axiom();
    Axiom const* get_if_axiom() const;
    Let& get_let();
    Let const& get_let() const;
    Let* get_if_let();
    Let const* get_if_let() const;
    template<CommandVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
    template<CommandConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  class SpanCommand {
    Command** begin_ptr;
    Command** end_ptr;
    SpanCommand(Command** begin_ptr, Command** end_ptr):begin_ptr(begin_ptr), end_ptr(end_ptr) {}
    friend Block;
  public:
    class ConstIterator;
    class Iterator {
      Command** pos;
      explicit Iterator(Command** pos):pos(pos) {}
      friend SpanCommand;
      friend ConstIterator;
    public:
      Command& operator*() const { return **pos; }
      Command* operator->() const { return *pos; }
      Iterator& operator++() { ++pos; return *this; }
      Iterator operator++(int) { auto ret = *this; ++pos; return ret; }
      friend constexpr bool operator!=(Iterator const& lhs, Iterator const& rhs) { return lhs.pos != rhs.pos; }
    };
    class ConstIterator {
      Command const** pos;
      explicit ConstIterator(Command const** pos):pos(pos) {}
      friend SpanCommand;
    public:
      ConstIterator(Iterator const& it):pos((Command const**)it.pos) {}
      Command const& operator*() const { return **pos; }
      Command const* operator->() const { return *pos; }
      ConstIterator& operator++() { ++pos; return *this; }
      ConstIterator operator++(int) { auto ret = *this; ++pos; return ret; }
      friend constexpr bool operator!=(ConstIterator const& lhs, ConstIterator const& rhs) { return lhs.pos != rhs.pos; }
    };
    SpanCommand(SpanCommand const&) = delete;
    SpanCommand(SpanCommand&&) = delete;
    SpanCommand& operator=(SpanCommand const&) = delete;
    SpanCommand& operator=(SpanCommand&&) = delete;
    std::size_t size() const { return end_ptr - begin_ptr; }
    Iterator begin() { return Iterator{begin_ptr}; }
    ConstIterator begin() const { return ConstIterator{(Command const**)begin_ptr}; }
    Iterator end() { return Iterator{end_ptr}; }
    ConstIterator end() const { return ConstIterator{(Command const**)end_ptr}; }
    Command& operator[](std::size_t index) { return *begin_ptr[index]; }
    Command const& operator[](std::size_t index) const { return *begin_ptr[index]; }
  };
  class Apply : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::output::archive_detail::Detail;
    Apply(std::size_t archive_index_private, Expression&, Expression&);
  public:
    Apply(Apply const&) = delete;
    Apply(Apply&&) = delete;
    Apply& operator=(Apply const&) = delete;
    Apply& operator=(Apply&&) = delete;
    expression_parser::archive_index::Apply index() const { return expression_parser::archive_index::Apply{private_index}; }
    Expression& lhs;
    Expression& rhs;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Lambda : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::output::archive_detail::Detail;
    Lambda(std::size_t archive_index_private, Expression&, Expression*, std::optional<std::string_view>);
  public:
    Lambda(Lambda const&) = delete;
    Lambda(Lambda&&) = delete;
    Lambda& operator=(Lambda const&) = delete;
    Lambda& operator=(Lambda&&) = delete;
    expression_parser::archive_index::Lambda index() const { return expression_parser::archive_index::Lambda{private_index}; }
    Expression& body;
    OptionalExpression type;
    std::optional<std::string_view> arg_name;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Identifier : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::output::archive_detail::Detail;
    Identifier(std::size_t archive_index_private, std::string_view);
  public:
    Identifier(Identifier const&) = delete;
    Identifier(Identifier&&) = delete;
    Identifier& operator=(Identifier const&) = delete;
    Identifier& operator=(Identifier&&) = delete;
    expression_parser::archive_index::Identifier index() const { return expression_parser::archive_index::Identifier{private_index}; }
    std::string_view id;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Hole : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::output::archive_detail::Detail;
    Hole(std::size_t archive_index_private);
  public:
    Hole(Hole const&) = delete;
    Hole(Hole&&) = delete;
    Hole& operator=(Hole const&) = delete;
    Hole& operator=(Hole&&) = delete;
    expression_parser::archive_index::Hole index() const { return expression_parser::archive_index::Hole{private_index}; }
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Arrow : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::output::archive_detail::Detail;
    Arrow(std::size_t archive_index_private, Expression&, Expression&, std::optional<std::string_view>);
  public:
    Arrow(Arrow const&) = delete;
    Arrow(Arrow&&) = delete;
    Arrow& operator=(Arrow const&) = delete;
    Arrow& operator=(Arrow&&) = delete;
    expression_parser::archive_index::Arrow index() const { return expression_parser::archive_index::Arrow{private_index}; }
    Expression& domain;
    Expression& codomain;
    std::optional<std::string_view> arg_name;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Block : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::output::archive_detail::Detail;
    Block(std::size_t archive_index_private, Command**, Command**, Expression&);
  public:
    Block(Block const&) = delete;
    Block(Block&&) = delete;
    Block& operator=(Block const&) = delete;
    Block& operator=(Block&&) = delete;
    expression_parser::archive_index::Block index() const { return expression_parser::archive_index::Block{private_index}; }
    SpanCommand statements;
    Expression& value;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Literal : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::output::archive_detail::Detail;
    Literal(std::size_t archive_index_private, literal::Any);
  public:
    Literal(Literal const&) = delete;
    Literal(Literal&&) = delete;
    Literal& operator=(Literal const&) = delete;
    Literal& operator=(Literal&&) = delete;
    expression_parser::archive_index::Literal index() const { return expression_parser::archive_index::Literal{private_index}; }
    literal::Any value;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class PatternApply : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::output::archive_detail::Detail;
    PatternApply(std::size_t archive_index_private, Pattern&, Pattern&);
  public:
    PatternApply(PatternApply const&) = delete;
    PatternApply(PatternApply&&) = delete;
    PatternApply& operator=(PatternApply const&) = delete;
    PatternApply& operator=(PatternApply&&) = delete;
    expression_parser::archive_index::PatternApply index() const { return expression_parser::archive_index::PatternApply{private_index}; }
    Pattern& lhs;
    Pattern& rhs;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class PatternIdentifier : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::output::archive_detail::Detail;
    PatternIdentifier(std::size_t archive_index_private, std::string_view);
  public:
    PatternIdentifier(PatternIdentifier const&) = delete;
    PatternIdentifier(PatternIdentifier&&) = delete;
    PatternIdentifier& operator=(PatternIdentifier const&) = delete;
    PatternIdentifier& operator=(PatternIdentifier&&) = delete;
    expression_parser::archive_index::PatternIdentifier index() const { return expression_parser::archive_index::PatternIdentifier{private_index}; }
    std::string_view id;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class PatternHole : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::output::archive_detail::Detail;
    PatternHole(std::size_t archive_index_private);
  public:
    PatternHole(PatternHole const&) = delete;
    PatternHole(PatternHole&&) = delete;
    PatternHole& operator=(PatternHole const&) = delete;
    PatternHole& operator=(PatternHole&&) = delete;
    expression_parser::archive_index::PatternHole index() const { return expression_parser::archive_index::PatternHole{private_index}; }
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class Declare : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::output::archive_detail::Detail;
    Declare(std::size_t archive_index_private, Expression&, std::string_view);
  public:
    Declare(Declare const&) = delete;
    Declare(Declare&&) = delete;
    Declare& operator=(Declare const&) = delete;
    Declare& operator=(Declare&&) = delete;
    expression_parser::archive_index::Declare index() const { return expression_parser::archive_index::Declare{private_index}; }
    Expression& type;
    std::string_view name;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Rule : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::output::archive_detail::Detail;
    Rule(std::size_t archive_index_private, Pattern&, Expression&);
  public:
    Rule(Rule const&) = delete;
    Rule(Rule&&) = delete;
    Rule& operator=(Rule const&) = delete;
    Rule& operator=(Rule&&) = delete;
    expression_parser::archive_index::Rule index() const { return expression_parser::archive_index::Rule{private_index}; }
    Pattern& pattern;
    Expression& replacement;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Axiom : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::output::archive_detail::Detail;
    Axiom(std::size_t archive_index_private, Expression&, std::string_view);
  public:
    Axiom(Axiom const&) = delete;
    Axiom(Axiom&&) = delete;
    Axiom& operator=(Axiom const&) = delete;
    Axiom& operator=(Axiom&&) = delete;
    expression_parser::archive_index::Axiom index() const { return expression_parser::archive_index::Axiom{private_index}; }
    Expression& type;
    std::string_view name;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Let : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::output::archive_detail::Detail;
    Let(std::size_t archive_index_private, Expression&, Expression*, std::string_view);
  public:
    Let(Let const&) = delete;
    Let(Let&&) = delete;
    Let& operator=(Let const&) = delete;
    Let& operator=(Let&&) = delete;
    expression_parser::archive_index::Let index() const { return expression_parser::archive_index::Let{private_index}; }
    Expression& value;
    OptionalExpression type;
    std::string_view name;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
}
namespace expression_parser::output::archive_root{
  class PolymorphicKind;
  class Expression {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Expression(expression_parser::output::Expression const&);
    Expression(expression_parser::output::Expression&&);
    Expression(Expression&& other):data(other.data) { other.data = nullptr; }
    Expression& operator=(Expression&& other) { std::swap(data, other.data); return *this; }
    ~Expression();
    archive_part::Expression& root() { return *(archive_part::Expression*)get_index(0); }
    archive_part::Expression const& root() const { return *(archive_part::Expression const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class Pattern {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Pattern(expression_parser::output::Pattern const&);
    Pattern(expression_parser::output::Pattern&&);
    Pattern(Pattern&& other):data(other.data) { other.data = nullptr; }
    Pattern& operator=(Pattern&& other) { std::swap(data, other.data); return *this; }
    ~Pattern();
    archive_part::Pattern& root() { return *(archive_part::Pattern*)get_index(0); }
    archive_part::Pattern const& root() const { return *(archive_part::Pattern const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class Command {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Command(expression_parser::output::Command const&);
    Command(expression_parser::output::Command&&);
    Command(Command&& other):data(other.data) { other.data = nullptr; }
    Command& operator=(Command&& other) { std::swap(data, other.data); return *this; }
    ~Command();
    archive_part::Command& root() { return *(archive_part::Command*)get_index(0); }
    archive_part::Command const& root() const { return *(archive_part::Command const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class PolymorphicKind {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
  public:
    PolymorphicKind(expression_parser::output::Expression const&);
    PolymorphicKind(expression_parser::output::Expression&&);
    PolymorphicKind(expression_parser::output::Pattern const&);
    PolymorphicKind(expression_parser::output::Pattern&&);
    PolymorphicKind(expression_parser::output::Command const&);
    PolymorphicKind(expression_parser::output::Command&&);
    PolymorphicKind(Expression&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(Pattern&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(Command&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(PolymorphicKind&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind& operator=(PolymorphicKind&& other) { std::swap(data, other.data); return *this; }
    ~PolymorphicKind();
    archive_part::PolymorphicKind& root() { return *(archive_part::PolymorphicKind*)get_index(0); }
    archive_part::PolymorphicKind const& root() const { return *(archive_part::PolymorphicKind const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
}
namespace expression_parser::output{
  inline archive_root::Expression archive(Expression const& target) { return archive_root::Expression{target}; }
  inline archive_root::Expression archive(Expression&& target) { return archive_root::Expression{std::move(target)}; }
  inline archive_root::Pattern archive(Pattern const& target) { return archive_root::Pattern{target}; }
  inline archive_root::Pattern archive(Pattern&& target) { return archive_root::Pattern{std::move(target)}; }
  inline archive_root::Command archive(Command const& target) { return archive_root::Command{target}; }
  inline archive_root::Command archive(Command&& target) { return archive_root::Command{std::move(target)}; }
}
namespace expression_parser::locator::archive_detail{
    struct Detail;
    static constexpr std::uint64_t kind_table[] = {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2};
}
namespace expression_parser::locator::archive_part{
  template<class Visitor> concept PolymorphicKindVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&>, std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&>, std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
  template<class Visitor> concept PolymorphicKindConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&>, std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&>, std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
  class PolymorphicKind {
    friend expression_parser::locator::archive_detail::Detail;
    friend Expression;
    friend Pattern;
    friend Command;
    friend Apply;
    friend Lambda;
    friend Identifier;
    friend Hole;
    friend Arrow;
    friend Block;
    friend Literal;
    friend PatternApply;
    friend PatternIdentifier;
    friend PatternHole;
    friend Declare;
    friend Rule;
    friend Axiom;
    friend Let;
    std::uint64_t const discriminator;
    std::uint64_t const private_index;
    PolymorphicKind(std::uint64_t discriminator, std::uint64_t private_index):discriminator(discriminator),private_index(private_index){}
    ~PolymorphicKind() {}
  public:
    PolymorphicKind(PolymorphicKind const&) = delete;
    PolymorphicKind(PolymorphicKind&&) = delete;
    PolymorphicKind& operator=(PolymorphicKind const&) = delete;
    PolymorphicKind& operator=(PolymorphicKind&&) = delete;
    expression_parser::archive_index::PolymorphicKind index() const { return expression_parser::archive_index::PolymorphicKind{private_index}; }
    Expression& get_expression();
    Expression const& get_expression() const;
    Expression* get_if_expression();
    Expression const* get_if_expression() const;
    Pattern& get_pattern();
    Pattern const& get_pattern() const;
    Pattern* get_if_pattern();
    Pattern const* get_if_pattern() const;
    Command& get_command();
    Command const& get_command() const;
    Command* get_if_command();
    Command const* get_if_command() const;
    Apply& get_apply();
    Apply const& get_apply() const;
    Apply* get_if_apply();
    Apply const* get_if_apply() const;
    Lambda& get_lambda();
    Lambda const& get_lambda() const;
    Lambda* get_if_lambda();
    Lambda const* get_if_lambda() const;
    Identifier& get_identifier();
    Identifier const& get_identifier() const;
    Identifier* get_if_identifier();
    Identifier const* get_if_identifier() const;
    Hole& get_hole();
    Hole const& get_hole() const;
    Hole* get_if_hole();
    Hole const* get_if_hole() const;
    Arrow& get_arrow();
    Arrow const& get_arrow() const;
    Arrow* get_if_arrow();
    Arrow const* get_if_arrow() const;
    Block& get_block();
    Block const& get_block() const;
    Block* get_if_block();
    Block const* get_if_block() const;
    Literal& get_literal();
    Literal const& get_literal() const;
    Literal* get_if_literal();
    Literal const* get_if_literal() const;
    PatternApply& get_pattern_apply();
    PatternApply const& get_pattern_apply() const;
    PatternApply* get_if_pattern_apply();
    PatternApply const* get_if_pattern_apply() const;
    PatternIdentifier& get_pattern_identifier();
    PatternIdentifier const& get_pattern_identifier() const;
    PatternIdentifier* get_if_pattern_identifier();
    PatternIdentifier const* get_if_pattern_identifier() const;
    PatternHole& get_pattern_hole();
    PatternHole const& get_pattern_hole() const;
    PatternHole* get_if_pattern_hole();
    PatternHole const* get_if_pattern_hole() const;
    Declare& get_declare();
    Declare const& get_declare() const;
    Declare* get_if_declare();
    Declare const* get_if_declare() const;
    Rule& get_rule();
    Rule const& get_rule() const;
    Rule* get_if_rule();
    Rule const* get_if_rule() const;
    Axiom& get_axiom();
    Axiom const& get_axiom() const;
    Axiom* get_if_axiom();
    Axiom const* get_if_axiom() const;
    Let& get_let();
    Let const& get_let() const;
    Let* get_if_let();
    Let const* get_if_let() const;
    template<PolymorphicKindVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&>, std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&>, std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
    template<PolymorphicKindConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&>, std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&>, std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
    template<class Visitor> auto visit_kind(Visitor&& visitor);
    template<class Visitor> auto visit_kind(Visitor&& visitor) const;
  };
  template<class Visitor> concept ExpressionVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
	};
  template<class Visitor> concept ExpressionConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
	};
  class Expression : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::locator::archive_detail::Detail;
    friend Apply;
    friend Lambda;
    friend Identifier;
    friend Hole;
    friend Arrow;
    friend Block;
    friend Literal;
    Expression(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Expression() {}
  public:
    Expression(Expression const&) = delete;
    Expression(Expression&&) = delete;
    Expression& operator=(Expression const&) = delete;
    Expression& operator=(Expression&&) = delete;
    expression_parser::archive_index::Expression index() const { return expression_parser::archive_index::Expression{private_index}; }
    Apply& get_apply();
    Apply const& get_apply() const;
    Apply* get_if_apply();
    Apply const* get_if_apply() const;
    Lambda& get_lambda();
    Lambda const& get_lambda() const;
    Lambda* get_if_lambda();
    Lambda const* get_if_lambda() const;
    Identifier& get_identifier();
    Identifier const& get_identifier() const;
    Identifier* get_if_identifier();
    Identifier const* get_if_identifier() const;
    Hole& get_hole();
    Hole const& get_hole() const;
    Hole* get_if_hole();
    Hole const* get_if_hole() const;
    Arrow& get_arrow();
    Arrow const& get_arrow() const;
    Arrow* get_if_arrow();
    Arrow const* get_if_arrow() const;
    Block& get_block();
    Block const& get_block() const;
    Block* get_if_block();
    Block const* get_if_block() const;
    Literal& get_literal();
    Literal const& get_literal() const;
    Literal* get_if_literal();
    Literal const* get_if_literal() const;
    template<ExpressionVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
    template<ExpressionConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  class OptionalExpression {
    Expression* ptr;
    OptionalExpression(Expression* ptr):ptr(ptr) {}
    friend Lambda;
    friend Let;
  public:
    OptionalExpression(OptionalExpression const&) = delete;
    OptionalExpression(OptionalExpression&&) = delete;
    OptionalExpression& operator=(OptionalExpression const&) = delete;
    OptionalExpression& operator=(OptionalExpression&&) = delete;
    operator bool() const { return ptr != nullptr; }
    Expression& operator*() { return *ptr; }
    Expression const& operator*() const { return *ptr; }
    Expression* operator->() { return ptr; }
    Expression const* operator->() const { return ptr; }
  };
  template<class Visitor> concept PatternVisitor = requires(Visitor visitor, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
	};
  template<class Visitor> concept PatternConstVisitor = requires(Visitor visitor, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
	};
  class Pattern : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::locator::archive_detail::Detail;
    friend PatternApply;
    friend PatternIdentifier;
    friend PatternHole;
    Pattern(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Pattern() {}
  public:
    Pattern(Pattern const&) = delete;
    Pattern(Pattern&&) = delete;
    Pattern& operator=(Pattern const&) = delete;
    Pattern& operator=(Pattern&&) = delete;
    expression_parser::archive_index::Pattern index() const { return expression_parser::archive_index::Pattern{private_index}; }
    PatternApply& get_pattern_apply();
    PatternApply const& get_pattern_apply() const;
    PatternApply* get_if_pattern_apply();
    PatternApply const* get_if_pattern_apply() const;
    PatternIdentifier& get_pattern_identifier();
    PatternIdentifier const& get_pattern_identifier() const;
    PatternIdentifier* get_if_pattern_identifier();
    PatternIdentifier const* get_if_pattern_identifier() const;
    PatternHole& get_pattern_hole();
    PatternHole const& get_pattern_hole() const;
    PatternHole* get_if_pattern_hole();
    PatternHole const* get_if_pattern_hole() const;
    template<PatternVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
    template<PatternConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  template<class Visitor> concept CommandVisitor = requires(Visitor visitor, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
  template<class Visitor> concept CommandConstVisitor = requires(Visitor visitor, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
  class Command : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::locator::archive_detail::Detail;
    friend Declare;
    friend Rule;
    friend Axiom;
    friend Let;
    Command(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Command() {}
  public:
    Command(Command const&) = delete;
    Command(Command&&) = delete;
    Command& operator=(Command const&) = delete;
    Command& operator=(Command&&) = delete;
    expression_parser::archive_index::Command index() const { return expression_parser::archive_index::Command{private_index}; }
    Declare& get_declare();
    Declare const& get_declare() const;
    Declare* get_if_declare();
    Declare const* get_if_declare() const;
    Rule& get_rule();
    Rule const& get_rule() const;
    Rule* get_if_rule();
    Rule const* get_if_rule() const;
    Axiom& get_axiom();
    Axiom const& get_axiom() const;
    Axiom* get_if_axiom();
    Axiom const* get_if_axiom() const;
    Let& get_let();
    Let const& get_let() const;
    Let* get_if_let();
    Let const* get_if_let() const;
    template<CommandVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
    template<CommandConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  class SpanCommand {
    Command** begin_ptr;
    Command** end_ptr;
    SpanCommand(Command** begin_ptr, Command** end_ptr):begin_ptr(begin_ptr), end_ptr(end_ptr) {}
    friend Block;
  public:
    class ConstIterator;
    class Iterator {
      Command** pos;
      explicit Iterator(Command** pos):pos(pos) {}
      friend SpanCommand;
      friend ConstIterator;
    public:
      Command& operator*() const { return **pos; }
      Command* operator->() const { return *pos; }
      Iterator& operator++() { ++pos; return *this; }
      Iterator operator++(int) { auto ret = *this; ++pos; return ret; }
      friend constexpr bool operator!=(Iterator const& lhs, Iterator const& rhs) { return lhs.pos != rhs.pos; }
    };
    class ConstIterator {
      Command const** pos;
      explicit ConstIterator(Command const** pos):pos(pos) {}
      friend SpanCommand;
    public:
      ConstIterator(Iterator const& it):pos((Command const**)it.pos) {}
      Command const& operator*() const { return **pos; }
      Command const* operator->() const { return *pos; }
      ConstIterator& operator++() { ++pos; return *this; }
      ConstIterator operator++(int) { auto ret = *this; ++pos; return ret; }
      friend constexpr bool operator!=(ConstIterator const& lhs, ConstIterator const& rhs) { return lhs.pos != rhs.pos; }
    };
    SpanCommand(SpanCommand const&) = delete;
    SpanCommand(SpanCommand&&) = delete;
    SpanCommand& operator=(SpanCommand const&) = delete;
    SpanCommand& operator=(SpanCommand&&) = delete;
    std::size_t size() const { return end_ptr - begin_ptr; }
    Iterator begin() { return Iterator{begin_ptr}; }
    ConstIterator begin() const { return ConstIterator{(Command const**)begin_ptr}; }
    Iterator end() { return Iterator{end_ptr}; }
    ConstIterator end() const { return ConstIterator{(Command const**)end_ptr}; }
    Command& operator[](std::size_t index) { return *begin_ptr[index]; }
    Command const& operator[](std::size_t index) const { return *begin_ptr[index]; }
  };
  class Apply : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::locator::archive_detail::Detail;
    Apply(std::size_t archive_index_private, Expression&, Expression&, std::string_view);
  public:
    Apply(Apply const&) = delete;
    Apply(Apply&&) = delete;
    Apply& operator=(Apply const&) = delete;
    Apply& operator=(Apply&&) = delete;
    expression_parser::archive_index::Apply index() const { return expression_parser::archive_index::Apply{private_index}; }
    Expression& lhs;
    Expression& rhs;
    std::string_view position;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Lambda : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::locator::archive_detail::Detail;
    Lambda(std::size_t archive_index_private, Expression&, Expression*, std::string_view);
  public:
    Lambda(Lambda const&) = delete;
    Lambda(Lambda&&) = delete;
    Lambda& operator=(Lambda const&) = delete;
    Lambda& operator=(Lambda&&) = delete;
    expression_parser::archive_index::Lambda index() const { return expression_parser::archive_index::Lambda{private_index}; }
    Expression& body;
    OptionalExpression type;
    std::string_view position;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Identifier : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::locator::archive_detail::Detail;
    Identifier(std::size_t archive_index_private, std::string_view);
  public:
    Identifier(Identifier const&) = delete;
    Identifier(Identifier&&) = delete;
    Identifier& operator=(Identifier const&) = delete;
    Identifier& operator=(Identifier&&) = delete;
    expression_parser::archive_index::Identifier index() const { return expression_parser::archive_index::Identifier{private_index}; }
    std::string_view position;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Hole : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::locator::archive_detail::Detail;
    Hole(std::size_t archive_index_private, std::string_view);
  public:
    Hole(Hole const&) = delete;
    Hole(Hole&&) = delete;
    Hole& operator=(Hole const&) = delete;
    Hole& operator=(Hole&&) = delete;
    expression_parser::archive_index::Hole index() const { return expression_parser::archive_index::Hole{private_index}; }
    std::string_view position;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Arrow : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::locator::archive_detail::Detail;
    Arrow(std::size_t archive_index_private, Expression&, Expression&, std::string_view);
  public:
    Arrow(Arrow const&) = delete;
    Arrow(Arrow&&) = delete;
    Arrow& operator=(Arrow const&) = delete;
    Arrow& operator=(Arrow&&) = delete;
    expression_parser::archive_index::Arrow index() const { return expression_parser::archive_index::Arrow{private_index}; }
    Expression& domain;
    Expression& codomain;
    std::string_view position;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Block : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::locator::archive_detail::Detail;
    Block(std::size_t archive_index_private, Command**, Command**, Expression&, std::string_view);
  public:
    Block(Block const&) = delete;
    Block(Block&&) = delete;
    Block& operator=(Block const&) = delete;
    Block& operator=(Block&&) = delete;
    expression_parser::archive_index::Block index() const { return expression_parser::archive_index::Block{private_index}; }
    SpanCommand statements;
    Expression& value;
    std::string_view position;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Literal : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::locator::archive_detail::Detail;
    Literal(std::size_t archive_index_private, std::string_view);
  public:
    Literal(Literal const&) = delete;
    Literal(Literal&&) = delete;
    Literal& operator=(Literal const&) = delete;
    Literal& operator=(Literal&&) = delete;
    expression_parser::archive_index::Literal index() const { return expression_parser::archive_index::Literal{private_index}; }
    std::string_view position;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class PatternApply : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::locator::archive_detail::Detail;
    PatternApply(std::size_t archive_index_private, Pattern&, Pattern&, std::string_view);
  public:
    PatternApply(PatternApply const&) = delete;
    PatternApply(PatternApply&&) = delete;
    PatternApply& operator=(PatternApply const&) = delete;
    PatternApply& operator=(PatternApply&&) = delete;
    expression_parser::archive_index::PatternApply index() const { return expression_parser::archive_index::PatternApply{private_index}; }
    Pattern& lhs;
    Pattern& rhs;
    std::string_view position;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class PatternIdentifier : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::locator::archive_detail::Detail;
    PatternIdentifier(std::size_t archive_index_private, std::string_view);
  public:
    PatternIdentifier(PatternIdentifier const&) = delete;
    PatternIdentifier(PatternIdentifier&&) = delete;
    PatternIdentifier& operator=(PatternIdentifier const&) = delete;
    PatternIdentifier& operator=(PatternIdentifier&&) = delete;
    expression_parser::archive_index::PatternIdentifier index() const { return expression_parser::archive_index::PatternIdentifier{private_index}; }
    std::string_view position;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class PatternHole : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::locator::archive_detail::Detail;
    PatternHole(std::size_t archive_index_private, std::string_view);
  public:
    PatternHole(PatternHole const&) = delete;
    PatternHole(PatternHole&&) = delete;
    PatternHole& operator=(PatternHole const&) = delete;
    PatternHole& operator=(PatternHole&&) = delete;
    expression_parser::archive_index::PatternHole index() const { return expression_parser::archive_index::PatternHole{private_index}; }
    std::string_view position;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class Declare : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::locator::archive_detail::Detail;
    Declare(std::size_t archive_index_private, Expression&, std::string_view);
  public:
    Declare(Declare const&) = delete;
    Declare(Declare&&) = delete;
    Declare& operator=(Declare const&) = delete;
    Declare& operator=(Declare&&) = delete;
    expression_parser::archive_index::Declare index() const { return expression_parser::archive_index::Declare{private_index}; }
    Expression& type;
    std::string_view position;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Rule : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::locator::archive_detail::Detail;
    Rule(std::size_t archive_index_private, Pattern&, Expression&, std::string_view);
  public:
    Rule(Rule const&) = delete;
    Rule(Rule&&) = delete;
    Rule& operator=(Rule const&) = delete;
    Rule& operator=(Rule&&) = delete;
    expression_parser::archive_index::Rule index() const { return expression_parser::archive_index::Rule{private_index}; }
    Pattern& pattern;
    Expression& replacement;
    std::string_view position;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Axiom : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::locator::archive_detail::Detail;
    Axiom(std::size_t archive_index_private, Expression&, std::string_view);
  public:
    Axiom(Axiom const&) = delete;
    Axiom(Axiom&&) = delete;
    Axiom& operator=(Axiom const&) = delete;
    Axiom& operator=(Axiom&&) = delete;
    expression_parser::archive_index::Axiom index() const { return expression_parser::archive_index::Axiom{private_index}; }
    Expression& type;
    std::string_view position;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Let : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::locator::archive_detail::Detail;
    Let(std::size_t archive_index_private, Expression&, Expression*, std::string_view);
  public:
    Let(Let const&) = delete;
    Let(Let&&) = delete;
    Let& operator=(Let const&) = delete;
    Let& operator=(Let&&) = delete;
    expression_parser::archive_index::Let index() const { return expression_parser::archive_index::Let{private_index}; }
    Expression& value;
    OptionalExpression type;
    std::string_view position;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
}
namespace expression_parser::locator::archive_root{
  class PolymorphicKind;
  class Expression {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Expression(expression_parser::locator::Expression const&);
    Expression(expression_parser::locator::Expression&&);
    Expression(Expression&& other):data(other.data) { other.data = nullptr; }
    Expression& operator=(Expression&& other) { std::swap(data, other.data); return *this; }
    ~Expression();
    archive_part::Expression& root() { return *(archive_part::Expression*)get_index(0); }
    archive_part::Expression const& root() const { return *(archive_part::Expression const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class Pattern {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Pattern(expression_parser::locator::Pattern const&);
    Pattern(expression_parser::locator::Pattern&&);
    Pattern(Pattern&& other):data(other.data) { other.data = nullptr; }
    Pattern& operator=(Pattern&& other) { std::swap(data, other.data); return *this; }
    ~Pattern();
    archive_part::Pattern& root() { return *(archive_part::Pattern*)get_index(0); }
    archive_part::Pattern const& root() const { return *(archive_part::Pattern const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class Command {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Command(expression_parser::locator::Command const&);
    Command(expression_parser::locator::Command&&);
    Command(Command&& other):data(other.data) { other.data = nullptr; }
    Command& operator=(Command&& other) { std::swap(data, other.data); return *this; }
    ~Command();
    archive_part::Command& root() { return *(archive_part::Command*)get_index(0); }
    archive_part::Command const& root() const { return *(archive_part::Command const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class PolymorphicKind {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
  public:
    PolymorphicKind(expression_parser::locator::Expression const&);
    PolymorphicKind(expression_parser::locator::Expression&&);
    PolymorphicKind(expression_parser::locator::Pattern const&);
    PolymorphicKind(expression_parser::locator::Pattern&&);
    PolymorphicKind(expression_parser::locator::Command const&);
    PolymorphicKind(expression_parser::locator::Command&&);
    PolymorphicKind(Expression&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(Pattern&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(Command&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(PolymorphicKind&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind& operator=(PolymorphicKind&& other) { std::swap(data, other.data); return *this; }
    ~PolymorphicKind();
    archive_part::PolymorphicKind& root() { return *(archive_part::PolymorphicKind*)get_index(0); }
    archive_part::PolymorphicKind const& root() const { return *(archive_part::PolymorphicKind const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
}
namespace expression_parser::locator{
  inline archive_root::Expression archive(Expression const& target) { return archive_root::Expression{target}; }
  inline archive_root::Expression archive(Expression&& target) { return archive_root::Expression{std::move(target)}; }
  inline archive_root::Pattern archive(Pattern const& target) { return archive_root::Pattern{target}; }
  inline archive_root::Pattern archive(Pattern&& target) { return archive_root::Pattern{std::move(target)}; }
  inline archive_root::Command archive(Command const& target) { return archive_root::Command{target}; }
  inline archive_root::Command archive(Command&& target) { return archive_root::Command{std::move(target)}; }
}
namespace expression_parser::resolved::archive_detail{
    struct Detail;
    static constexpr std::uint64_t kind_table[] = {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2};
}
namespace expression_parser::resolved::archive_part{
  template<class Visitor> concept PolymorphicKindVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&>, std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&>, std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
  template<class Visitor> concept PolymorphicKindConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&>, std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&>, std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
  class PolymorphicKind {
    friend expression_parser::resolved::archive_detail::Detail;
    friend Expression;
    friend Pattern;
    friend Command;
    friend Apply;
    friend Lambda;
    friend Identifier;
    friend Hole;
    friend Arrow;
    friend Block;
    friend Literal;
    friend PatternApply;
    friend PatternIdentifier;
    friend PatternHole;
    friend Declare;
    friend Rule;
    friend Axiom;
    friend Let;
    std::uint64_t const discriminator;
    std::uint64_t const private_index;
    PolymorphicKind(std::uint64_t discriminator, std::uint64_t private_index):discriminator(discriminator),private_index(private_index){}
    ~PolymorphicKind() {}
  public:
    PolymorphicKind(PolymorphicKind const&) = delete;
    PolymorphicKind(PolymorphicKind&&) = delete;
    PolymorphicKind& operator=(PolymorphicKind const&) = delete;
    PolymorphicKind& operator=(PolymorphicKind&&) = delete;
    expression_parser::archive_index::PolymorphicKind index() const { return expression_parser::archive_index::PolymorphicKind{private_index}; }
    Expression& get_expression();
    Expression const& get_expression() const;
    Expression* get_if_expression();
    Expression const* get_if_expression() const;
    Pattern& get_pattern();
    Pattern const& get_pattern() const;
    Pattern* get_if_pattern();
    Pattern const* get_if_pattern() const;
    Command& get_command();
    Command const& get_command() const;
    Command* get_if_command();
    Command const* get_if_command() const;
    Apply& get_apply();
    Apply const& get_apply() const;
    Apply* get_if_apply();
    Apply const* get_if_apply() const;
    Lambda& get_lambda();
    Lambda const& get_lambda() const;
    Lambda* get_if_lambda();
    Lambda const* get_if_lambda() const;
    Identifier& get_identifier();
    Identifier const& get_identifier() const;
    Identifier* get_if_identifier();
    Identifier const* get_if_identifier() const;
    Hole& get_hole();
    Hole const& get_hole() const;
    Hole* get_if_hole();
    Hole const* get_if_hole() const;
    Arrow& get_arrow();
    Arrow const& get_arrow() const;
    Arrow* get_if_arrow();
    Arrow const* get_if_arrow() const;
    Block& get_block();
    Block const& get_block() const;
    Block* get_if_block();
    Block const* get_if_block() const;
    Literal& get_literal();
    Literal const& get_literal() const;
    Literal* get_if_literal();
    Literal const* get_if_literal() const;
    PatternApply& get_pattern_apply();
    PatternApply const& get_pattern_apply() const;
    PatternApply* get_if_pattern_apply();
    PatternApply const* get_if_pattern_apply() const;
    PatternIdentifier& get_pattern_identifier();
    PatternIdentifier const& get_pattern_identifier() const;
    PatternIdentifier* get_if_pattern_identifier();
    PatternIdentifier const* get_if_pattern_identifier() const;
    PatternHole& get_pattern_hole();
    PatternHole const& get_pattern_hole() const;
    PatternHole* get_if_pattern_hole();
    PatternHole const* get_if_pattern_hole() const;
    Declare& get_declare();
    Declare const& get_declare() const;
    Declare* get_if_declare();
    Declare const* get_if_declare() const;
    Rule& get_rule();
    Rule const& get_rule() const;
    Rule* get_if_rule();
    Rule const* get_if_rule() const;
    Axiom& get_axiom();
    Axiom const& get_axiom() const;
    Axiom* get_if_axiom();
    Axiom const* get_if_axiom() const;
    Let& get_let();
    Let const& get_let() const;
    Let* get_if_let();
    Let const* get_if_let() const;
    template<PolymorphicKindVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&>, std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&>, std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
    template<PolymorphicKindConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&>, std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&>, std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
    template<class Visitor> auto visit_kind(Visitor&& visitor);
    template<class Visitor> auto visit_kind(Visitor&& visitor) const;
  };
  template<class Visitor> concept ExpressionVisitor = requires(Visitor visitor, Apply& apply, Lambda& lambda, Identifier& identifier, Hole& hole, Arrow& arrow, Block& block, Literal& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
	};
  template<class Visitor> concept ExpressionConstVisitor = requires(Visitor visitor, Apply const& apply, Lambda const& lambda, Identifier const& identifier, Hole const& hole, Arrow const& arrow, Block const& block, Literal const& literal) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(lambda);
		std::forward<Visitor>(visitor)(identifier);
		std::forward<Visitor>(visitor)(hole);
		std::forward<Visitor>(visitor)(arrow);
		std::forward<Visitor>(visitor)(block);
		std::forward<Visitor>(visitor)(literal);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
	};
  class Expression : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::resolved::archive_detail::Detail;
    friend Apply;
    friend Lambda;
    friend Identifier;
    friend Hole;
    friend Arrow;
    friend Block;
    friend Literal;
    Expression(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Expression() {}
  public:
    Expression(Expression const&) = delete;
    Expression(Expression&&) = delete;
    Expression& operator=(Expression const&) = delete;
    Expression& operator=(Expression&&) = delete;
    expression_parser::archive_index::Expression index() const { return expression_parser::archive_index::Expression{private_index}; }
    Apply& get_apply();
    Apply const& get_apply() const;
    Apply* get_if_apply();
    Apply const* get_if_apply() const;
    Lambda& get_lambda();
    Lambda const& get_lambda() const;
    Lambda* get_if_lambda();
    Lambda const* get_if_lambda() const;
    Identifier& get_identifier();
    Identifier const& get_identifier() const;
    Identifier* get_if_identifier();
    Identifier const* get_if_identifier() const;
    Hole& get_hole();
    Hole const& get_hole() const;
    Hole* get_if_hole();
    Hole const* get_if_hole() const;
    Arrow& get_arrow();
    Arrow const& get_arrow() const;
    Arrow* get_if_arrow();
    Arrow const* get_if_arrow() const;
    Block& get_block();
    Block const& get_block() const;
    Block* get_if_block();
    Block const* get_if_block() const;
    Literal& get_literal();
    Literal const& get_literal() const;
    Literal* get_if_literal();
    Literal const* get_if_literal() const;
    template<ExpressionVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Lambda&>, std::invoke_result_t<Visitor&&, Identifier&>, std::invoke_result_t<Visitor&&, Hole&>, std::invoke_result_t<Visitor&&, Arrow&>, std::invoke_result_t<Visitor&&, Block&>, std::invoke_result_t<Visitor&&, Literal&> >;
    template<ExpressionConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Lambda const&>, std::invoke_result_t<Visitor&&, Identifier const&>, std::invoke_result_t<Visitor&&, Hole const&>, std::invoke_result_t<Visitor&&, Arrow const&>, std::invoke_result_t<Visitor&&, Block const&>, std::invoke_result_t<Visitor&&, Literal const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  class OptionalExpression {
    Expression* ptr;
    OptionalExpression(Expression* ptr):ptr(ptr) {}
    friend Lambda;
    friend Let;
  public:
    OptionalExpression(OptionalExpression const&) = delete;
    OptionalExpression(OptionalExpression&&) = delete;
    OptionalExpression& operator=(OptionalExpression const&) = delete;
    OptionalExpression& operator=(OptionalExpression&&) = delete;
    operator bool() const { return ptr != nullptr; }
    Expression& operator*() { return *ptr; }
    Expression const& operator*() const { return *ptr; }
    Expression* operator->() { return ptr; }
    Expression const* operator->() const { return ptr; }
  };
  template<class Visitor> concept PatternVisitor = requires(Visitor visitor, PatternApply& pattern_apply, PatternIdentifier& pattern_identifier, PatternHole& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
	};
  template<class Visitor> concept PatternConstVisitor = requires(Visitor visitor, PatternApply const& pattern_apply, PatternIdentifier const& pattern_identifier, PatternHole const& pattern_hole) {
		std::forward<Visitor>(visitor)(pattern_apply);
		std::forward<Visitor>(visitor)(pattern_identifier);
		std::forward<Visitor>(visitor)(pattern_hole);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
	};
  class Pattern : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::resolved::archive_detail::Detail;
    friend PatternApply;
    friend PatternIdentifier;
    friend PatternHole;
    Pattern(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Pattern() {}
  public:
    Pattern(Pattern const&) = delete;
    Pattern(Pattern&&) = delete;
    Pattern& operator=(Pattern const&) = delete;
    Pattern& operator=(Pattern&&) = delete;
    expression_parser::archive_index::Pattern index() const { return expression_parser::archive_index::Pattern{private_index}; }
    PatternApply& get_pattern_apply();
    PatternApply const& get_pattern_apply() const;
    PatternApply* get_if_pattern_apply();
    PatternApply const* get_if_pattern_apply() const;
    PatternIdentifier& get_pattern_identifier();
    PatternIdentifier const& get_pattern_identifier() const;
    PatternIdentifier* get_if_pattern_identifier();
    PatternIdentifier const* get_if_pattern_identifier() const;
    PatternHole& get_pattern_hole();
    PatternHole const& get_pattern_hole() const;
    PatternHole* get_if_pattern_hole();
    PatternHole const* get_if_pattern_hole() const;
    template<PatternVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply&>, std::invoke_result_t<Visitor&&, PatternIdentifier&>, std::invoke_result_t<Visitor&&, PatternHole&> >;
    template<PatternConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, PatternApply const&>, std::invoke_result_t<Visitor&&, PatternIdentifier const&>, std::invoke_result_t<Visitor&&, PatternHole const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  template<class Visitor> concept CommandVisitor = requires(Visitor visitor, Declare& declare, Rule& rule, Axiom& axiom, Let& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
	};
  template<class Visitor> concept CommandConstVisitor = requires(Visitor visitor, Declare const& declare, Rule const& rule, Axiom const& axiom, Let const& let) {
		std::forward<Visitor>(visitor)(declare);
		std::forward<Visitor>(visitor)(rule);
		std::forward<Visitor>(visitor)(axiom);
		std::forward<Visitor>(visitor)(let);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
	};
  class Command : private PolymorphicKind {
    friend PolymorphicKind;
    friend expression_parser::resolved::archive_detail::Detail;
    friend Declare;
    friend Rule;
    friend Axiom;
    friend Let;
    Command(std::uint64_t discriminator, std::uint64_t index):PolymorphicKind(discriminator, index){}
    ~Command() {}
  public:
    Command(Command const&) = delete;
    Command(Command&&) = delete;
    Command& operator=(Command const&) = delete;
    Command& operator=(Command&&) = delete;
    expression_parser::archive_index::Command index() const { return expression_parser::archive_index::Command{private_index}; }
    Declare& get_declare();
    Declare const& get_declare() const;
    Declare* get_if_declare();
    Declare const* get_if_declare() const;
    Rule& get_rule();
    Rule const& get_rule() const;
    Rule* get_if_rule();
    Rule const* get_if_rule() const;
    Axiom& get_axiom();
    Axiom const& get_axiom() const;
    Axiom* get_if_axiom();
    Axiom const* get_if_axiom() const;
    Let& get_let();
    Let const& get_let() const;
    Let* get_if_let();
    Let const* get_if_let() const;
    template<CommandVisitor Visitor> auto visit(Visitor&& visitor) -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare&>, std::invoke_result_t<Visitor&&, Rule&>, std::invoke_result_t<Visitor&&, Axiom&>, std::invoke_result_t<Visitor&&, Let&> >;
    template<CommandConstVisitor Visitor> auto visit(Visitor&& visitor) const -> std::common_type_t<std::invoke_result_t<Visitor&&, Declare const&>, std::invoke_result_t<Visitor&&, Rule const&>, std::invoke_result_t<Visitor&&, Axiom const&>, std::invoke_result_t<Visitor&&, Let const&> >;
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)this; }
  };
  class SpanCommand {
    Command** begin_ptr;
    Command** end_ptr;
    SpanCommand(Command** begin_ptr, Command** end_ptr):begin_ptr(begin_ptr), end_ptr(end_ptr) {}
    friend Block;
  public:
    class ConstIterator;
    class Iterator {
      Command** pos;
      explicit Iterator(Command** pos):pos(pos) {}
      friend SpanCommand;
      friend ConstIterator;
    public:
      Command& operator*() const { return **pos; }
      Command* operator->() const { return *pos; }
      Iterator& operator++() { ++pos; return *this; }
      Iterator operator++(int) { auto ret = *this; ++pos; return ret; }
      friend constexpr bool operator!=(Iterator const& lhs, Iterator const& rhs) { return lhs.pos != rhs.pos; }
    };
    class ConstIterator {
      Command const** pos;
      explicit ConstIterator(Command const** pos):pos(pos) {}
      friend SpanCommand;
    public:
      ConstIterator(Iterator const& it):pos((Command const**)it.pos) {}
      Command const& operator*() const { return **pos; }
      Command const* operator->() const { return *pos; }
      ConstIterator& operator++() { ++pos; return *this; }
      ConstIterator operator++(int) { auto ret = *this; ++pos; return ret; }
      friend constexpr bool operator!=(ConstIterator const& lhs, ConstIterator const& rhs) { return lhs.pos != rhs.pos; }
    };
    SpanCommand(SpanCommand const&) = delete;
    SpanCommand(SpanCommand&&) = delete;
    SpanCommand& operator=(SpanCommand const&) = delete;
    SpanCommand& operator=(SpanCommand&&) = delete;
    std::size_t size() const { return end_ptr - begin_ptr; }
    Iterator begin() { return Iterator{begin_ptr}; }
    ConstIterator begin() const { return ConstIterator{(Command const**)begin_ptr}; }
    Iterator end() { return Iterator{end_ptr}; }
    ConstIterator end() const { return ConstIterator{(Command const**)end_ptr}; }
    Command& operator[](std::size_t index) { return *begin_ptr[index]; }
    Command const& operator[](std::size_t index) const { return *begin_ptr[index]; }
  };
  class Apply : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::resolved::archive_detail::Detail;
    Apply(std::size_t archive_index_private, Expression&, Expression&);
  public:
    Apply(Apply const&) = delete;
    Apply(Apply&&) = delete;
    Apply& operator=(Apply const&) = delete;
    Apply& operator=(Apply&&) = delete;
    expression_parser::archive_index::Apply index() const { return expression_parser::archive_index::Apply{private_index}; }
    Expression& lhs;
    Expression& rhs;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Lambda : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::resolved::archive_detail::Detail;
    Lambda(std::size_t archive_index_private, Expression&, Expression*);
  public:
    Lambda(Lambda const&) = delete;
    Lambda(Lambda&&) = delete;
    Lambda& operator=(Lambda const&) = delete;
    Lambda& operator=(Lambda&&) = delete;
    expression_parser::archive_index::Lambda index() const { return expression_parser::archive_index::Lambda{private_index}; }
    Expression& body;
    OptionalExpression type;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Identifier : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::resolved::archive_detail::Detail;
    Identifier(std::size_t archive_index_private, bool, std::uint64_t);
  public:
    Identifier(Identifier const&) = delete;
    Identifier(Identifier&&) = delete;
    Identifier& operator=(Identifier const&) = delete;
    Identifier& operator=(Identifier&&) = delete;
    expression_parser::archive_index::Identifier index() const { return expression_parser::archive_index::Identifier{private_index}; }
    bool is_local;
    std::uint64_t var_index;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Hole : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::resolved::archive_detail::Detail;
    Hole(std::size_t archive_index_private);
  public:
    Hole(Hole const&) = delete;
    Hole(Hole&&) = delete;
    Hole& operator=(Hole const&) = delete;
    Hole& operator=(Hole&&) = delete;
    expression_parser::archive_index::Hole index() const { return expression_parser::archive_index::Hole{private_index}; }
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Arrow : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::resolved::archive_detail::Detail;
    Arrow(std::size_t archive_index_private, Expression&, Expression&);
  public:
    Arrow(Arrow const&) = delete;
    Arrow(Arrow&&) = delete;
    Arrow& operator=(Arrow const&) = delete;
    Arrow& operator=(Arrow&&) = delete;
    expression_parser::archive_index::Arrow index() const { return expression_parser::archive_index::Arrow{private_index}; }
    Expression& domain;
    Expression& codomain;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Block : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::resolved::archive_detail::Detail;
    Block(std::size_t archive_index_private, Command**, Command**, Expression&);
  public:
    Block(Block const&) = delete;
    Block(Block&&) = delete;
    Block& operator=(Block const&) = delete;
    Block& operator=(Block&&) = delete;
    expression_parser::archive_index::Block index() const { return expression_parser::archive_index::Block{private_index}; }
    SpanCommand statements;
    Expression& value;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class Literal : private Expression {
    friend PolymorphicKind;
    friend Expression;
    friend expression_parser::resolved::archive_detail::Detail;
    Literal(std::size_t archive_index_private, std::uint64_t);
  public:
    Literal(Literal const&) = delete;
    Literal(Literal&&) = delete;
    Literal& operator=(Literal const&) = delete;
    Literal& operator=(Literal&&) = delete;
    expression_parser::archive_index::Literal index() const { return expression_parser::archive_index::Literal{private_index}; }
    std::uint64_t embed_index;
    Expression& as_expression() { return *(Expression*)this; }
    Expression const& as_expression() const { return *(Expression const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Expression*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Expression const*)this; }
  };
  class PatternApply : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::resolved::archive_detail::Detail;
    PatternApply(std::size_t archive_index_private, Pattern&, Pattern&);
  public:
    PatternApply(PatternApply const&) = delete;
    PatternApply(PatternApply&&) = delete;
    PatternApply& operator=(PatternApply const&) = delete;
    PatternApply& operator=(PatternApply&&) = delete;
    expression_parser::archive_index::PatternApply index() const { return expression_parser::archive_index::PatternApply{private_index}; }
    Pattern& lhs;
    Pattern& rhs;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class PatternIdentifier : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::resolved::archive_detail::Detail;
    PatternIdentifier(std::size_t archive_index_private, bool, std::uint64_t);
  public:
    PatternIdentifier(PatternIdentifier const&) = delete;
    PatternIdentifier(PatternIdentifier&&) = delete;
    PatternIdentifier& operator=(PatternIdentifier const&) = delete;
    PatternIdentifier& operator=(PatternIdentifier&&) = delete;
    expression_parser::archive_index::PatternIdentifier index() const { return expression_parser::archive_index::PatternIdentifier{private_index}; }
    bool is_local;
    std::uint64_t var_index;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class PatternHole : private Pattern {
    friend PolymorphicKind;
    friend Pattern;
    friend expression_parser::resolved::archive_detail::Detail;
    PatternHole(std::size_t archive_index_private, std::uint64_t);
  public:
    PatternHole(PatternHole const&) = delete;
    PatternHole(PatternHole&&) = delete;
    PatternHole& operator=(PatternHole const&) = delete;
    PatternHole& operator=(PatternHole&&) = delete;
    expression_parser::archive_index::PatternHole index() const { return expression_parser::archive_index::PatternHole{private_index}; }
    std::uint64_t var_index;
    Pattern& as_pattern() { return *(Pattern*)this; }
    Pattern const& as_pattern() const { return *(Pattern const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Pattern*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Pattern const*)this; }
  };
  class Declare : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::resolved::archive_detail::Detail;
    Declare(std::size_t archive_index_private, Expression&);
  public:
    Declare(Declare const&) = delete;
    Declare(Declare&&) = delete;
    Declare& operator=(Declare const&) = delete;
    Declare& operator=(Declare&&) = delete;
    expression_parser::archive_index::Declare index() const { return expression_parser::archive_index::Declare{private_index}; }
    Expression& type;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Rule : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::resolved::archive_detail::Detail;
    Rule(std::size_t archive_index_private, Pattern&, Expression&, std::uint64_t);
  public:
    Rule(Rule const&) = delete;
    Rule(Rule&&) = delete;
    Rule& operator=(Rule const&) = delete;
    Rule& operator=(Rule&&) = delete;
    expression_parser::archive_index::Rule index() const { return expression_parser::archive_index::Rule{private_index}; }
    Pattern& pattern;
    Expression& replacement;
    std::uint64_t args_in_pattern;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Axiom : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::resolved::archive_detail::Detail;
    Axiom(std::size_t archive_index_private, Expression&);
  public:
    Axiom(Axiom const&) = delete;
    Axiom(Axiom&&) = delete;
    Axiom& operator=(Axiom const&) = delete;
    Axiom& operator=(Axiom&&) = delete;
    expression_parser::archive_index::Axiom index() const { return expression_parser::archive_index::Axiom{private_index}; }
    Expression& type;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
  class Let : private Command {
    friend PolymorphicKind;
    friend Command;
    friend expression_parser::resolved::archive_detail::Detail;
    Let(std::size_t archive_index_private, Expression&, Expression*);
  public:
    Let(Let const&) = delete;
    Let(Let&&) = delete;
    Let& operator=(Let const&) = delete;
    Let& operator=(Let&&) = delete;
    expression_parser::archive_index::Let index() const { return expression_parser::archive_index::Let{private_index}; }
    Expression& value;
    OptionalExpression type;
    Command& as_command() { return *(Command*)this; }
    Command const& as_command() const { return *(Command const*)this; }
    PolymorphicKind& as_poly() { return *(PolymorphicKind*)(Command*)this; }
    PolymorphicKind const& as_poly() const { return *(PolymorphicKind const*)(Command const*)this; }
  };
}
namespace expression_parser::resolved::archive_root{
  class PolymorphicKind;
  class Expression {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Expression(expression_parser::resolved::Expression const&);
    Expression(expression_parser::resolved::Expression&&);
    Expression(Expression&& other):data(other.data) { other.data = nullptr; }
    Expression& operator=(Expression&& other) { std::swap(data, other.data); return *this; }
    ~Expression();
    archive_part::Expression& root() { return *(archive_part::Expression*)get_index(0); }
    archive_part::Expression const& root() const { return *(archive_part::Expression const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class Pattern {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Pattern(expression_parser::resolved::Pattern const&);
    Pattern(expression_parser::resolved::Pattern&&);
    Pattern(Pattern&& other):data(other.data) { other.data = nullptr; }
    Pattern& operator=(Pattern&& other) { std::swap(data, other.data); return *this; }
    ~Pattern();
    archive_part::Pattern& root() { return *(archive_part::Pattern*)get_index(0); }
    archive_part::Pattern const& root() const { return *(archive_part::Pattern const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class Command {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
    friend PolymorphicKind;
  public:
    Command(expression_parser::resolved::Command const&);
    Command(expression_parser::resolved::Command&&);
    Command(Command&& other):data(other.data) { other.data = nullptr; }
    Command& operator=(Command&& other) { std::swap(data, other.data); return *this; }
    ~Command();
    archive_part::Command& root() { return *(archive_part::Command*)get_index(0); }
    archive_part::Command const& root() const { return *(archive_part::Command const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
  class PolymorphicKind {
    void* data;
    archive_part::PolymorphicKind const* get_index(std::uint64_t index) const { return *((archive_part::PolymorphicKind**)data + index); }
    archive_part::PolymorphicKind* get_index(std::uint64_t index) { return *((archive_part::PolymorphicKind**)data + index); }
  public:
    PolymorphicKind(expression_parser::resolved::Expression const&);
    PolymorphicKind(expression_parser::resolved::Expression&&);
    PolymorphicKind(expression_parser::resolved::Pattern const&);
    PolymorphicKind(expression_parser::resolved::Pattern&&);
    PolymorphicKind(expression_parser::resolved::Command const&);
    PolymorphicKind(expression_parser::resolved::Command&&);
    PolymorphicKind(Expression&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(Pattern&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(Command&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind(PolymorphicKind&& other):data(other.data) { other.data = nullptr; }
    PolymorphicKind& operator=(PolymorphicKind&& other) { std::swap(data, other.data); return *this; }
    ~PolymorphicKind();
    archive_part::PolymorphicKind& root() { return *(archive_part::PolymorphicKind*)get_index(0); }
    archive_part::PolymorphicKind const& root() const { return *(archive_part::PolymorphicKind const*)get_index(0); }
    archive_part::PolymorphicKind& operator[](expression_parser::archive_index::PolymorphicKind index) { return *(archive_part::PolymorphicKind*)get_index(index.index()); }
    archive_part::PolymorphicKind const& operator[](expression_parser::archive_index::PolymorphicKind index) const { return *(archive_part::PolymorphicKind const*)get_index(index.index()); }
    archive_part::Expression& operator[](expression_parser::archive_index::Expression index) { return *(archive_part::Expression*)get_index(index.index()); }
    archive_part::Expression const& operator[](expression_parser::archive_index::Expression index) const { return *(archive_part::Expression const*)get_index(index.index()); }
    archive_part::Pattern& operator[](expression_parser::archive_index::Pattern index) { return *(archive_part::Pattern*)get_index(index.index()); }
    archive_part::Pattern const& operator[](expression_parser::archive_index::Pattern index) const { return *(archive_part::Pattern const*)get_index(index.index()); }
    archive_part::Command& operator[](expression_parser::archive_index::Command index) { return *(archive_part::Command*)get_index(index.index()); }
    archive_part::Command const& operator[](expression_parser::archive_index::Command index) const { return *(archive_part::Command const*)get_index(index.index()); }
    archive_part::Apply& operator[](expression_parser::archive_index::Apply index) { return *(archive_part::Apply*)get_index(index.index()); }
    archive_part::Apply const& operator[](expression_parser::archive_index::Apply index) const { return *(archive_part::Apply const*)get_index(index.index()); }
    archive_part::Lambda& operator[](expression_parser::archive_index::Lambda index) { return *(archive_part::Lambda*)get_index(index.index()); }
    archive_part::Lambda const& operator[](expression_parser::archive_index::Lambda index) const { return *(archive_part::Lambda const*)get_index(index.index()); }
    archive_part::Identifier& operator[](expression_parser::archive_index::Identifier index) { return *(archive_part::Identifier*)get_index(index.index()); }
    archive_part::Identifier const& operator[](expression_parser::archive_index::Identifier index) const { return *(archive_part::Identifier const*)get_index(index.index()); }
    archive_part::Hole& operator[](expression_parser::archive_index::Hole index) { return *(archive_part::Hole*)get_index(index.index()); }
    archive_part::Hole const& operator[](expression_parser::archive_index::Hole index) const { return *(archive_part::Hole const*)get_index(index.index()); }
    archive_part::Arrow& operator[](expression_parser::archive_index::Arrow index) { return *(archive_part::Arrow*)get_index(index.index()); }
    archive_part::Arrow const& operator[](expression_parser::archive_index::Arrow index) const { return *(archive_part::Arrow const*)get_index(index.index()); }
    archive_part::Block& operator[](expression_parser::archive_index::Block index) { return *(archive_part::Block*)get_index(index.index()); }
    archive_part::Block const& operator[](expression_parser::archive_index::Block index) const { return *(archive_part::Block const*)get_index(index.index()); }
    archive_part::Literal& operator[](expression_parser::archive_index::Literal index) { return *(archive_part::Literal*)get_index(index.index()); }
    archive_part::Literal const& operator[](expression_parser::archive_index::Literal index) const { return *(archive_part::Literal const*)get_index(index.index()); }
    archive_part::PatternApply& operator[](expression_parser::archive_index::PatternApply index) { return *(archive_part::PatternApply*)get_index(index.index()); }
    archive_part::PatternApply const& operator[](expression_parser::archive_index::PatternApply index) const { return *(archive_part::PatternApply const*)get_index(index.index()); }
    archive_part::PatternIdentifier& operator[](expression_parser::archive_index::PatternIdentifier index) { return *(archive_part::PatternIdentifier*)get_index(index.index()); }
    archive_part::PatternIdentifier const& operator[](expression_parser::archive_index::PatternIdentifier index) const { return *(archive_part::PatternIdentifier const*)get_index(index.index()); }
    archive_part::PatternHole& operator[](expression_parser::archive_index::PatternHole index) { return *(archive_part::PatternHole*)get_index(index.index()); }
    archive_part::PatternHole const& operator[](expression_parser::archive_index::PatternHole index) const { return *(archive_part::PatternHole const*)get_index(index.index()); }
    archive_part::Declare& operator[](expression_parser::archive_index::Declare index) { return *(archive_part::Declare*)get_index(index.index()); }
    archive_part::Declare const& operator[](expression_parser::archive_index::Declare index) const { return *(archive_part::Declare const*)get_index(index.index()); }
    archive_part::Rule& operator[](expression_parser::archive_index::Rule index) { return *(archive_part::Rule*)get_index(index.index()); }
    archive_part::Rule const& operator[](expression_parser::archive_index::Rule index) const { return *(archive_part::Rule const*)get_index(index.index()); }
    archive_part::Axiom& operator[](expression_parser::archive_index::Axiom index) { return *(archive_part::Axiom*)get_index(index.index()); }
    archive_part::Axiom const& operator[](expression_parser::archive_index::Axiom index) const { return *(archive_part::Axiom const*)get_index(index.index()); }
    archive_part::Let& operator[](expression_parser::archive_index::Let index) { return *(archive_part::Let*)get_index(index.index()); }
    archive_part::Let const& operator[](expression_parser::archive_index::Let index) const { return *(archive_part::Let const*)get_index(index.index()); }
  };
}
namespace expression_parser::resolved{
  inline archive_root::Expression archive(Expression const& target) { return archive_root::Expression{target}; }
  inline archive_root::Expression archive(Expression&& target) { return archive_root::Expression{std::move(target)}; }
  inline archive_root::Pattern archive(Pattern const& target) { return archive_root::Pattern{target}; }
  inline archive_root::Pattern archive(Pattern&& target) { return archive_root::Pattern{std::move(target)}; }
  inline archive_root::Command archive(Command const& target) { return archive_root::Command{target}; }
  inline archive_root::Command archive(Command&& target) { return archive_root::Command{std::move(target)}; }
}
namespace expression_parser::output::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Expression const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Pattern const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Command const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct ExpressionFormatter { Expression const& tree; Formatter formatter; };
	template<class Formatter> struct PatternFormatter { Pattern const& tree; Formatter formatter; };
	template<class Formatter> struct CommandFormatter { Command const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression_parser::output{
	template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format_detail::ExpressionFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Expression const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format_detail::PatternFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Pattern const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format_detail::CommandFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Command const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
namespace expression_parser::locator::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Expression const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Pattern const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Command const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct ExpressionFormatter { Expression const& tree; Formatter formatter; };
	template<class Formatter> struct PatternFormatter { Pattern const& tree; Formatter formatter; };
	template<class Formatter> struct CommandFormatter { Command const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression_parser::locator{
	template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format_detail::ExpressionFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Expression const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format_detail::PatternFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Pattern const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format_detail::CommandFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Command const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
namespace expression_parser::resolved::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Expression const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Pattern const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Command const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct ExpressionFormatter { Expression const& tree; Formatter formatter; };
	template<class Formatter> struct PatternFormatter { Pattern const& tree; Formatter formatter; };
	template<class Formatter> struct CommandFormatter { Command const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression_parser::resolved{
	template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format_detail::ExpressionFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Expression const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format_detail::PatternFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Pattern const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format_detail::CommandFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Command const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
namespace expression_parser::output::archive_part::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Expression const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Pattern const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Command const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct ExpressionFormatter { Expression const& tree; Formatter formatter; };
	template<class Formatter> struct PatternFormatter { Pattern const& tree; Formatter formatter; };
	template<class Formatter> struct CommandFormatter { Command const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression_parser::output::archive_part{
	template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format_detail::ExpressionFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Expression const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format_detail::PatternFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Pattern const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format_detail::CommandFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Command const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
namespace expression_parser::output::archive_root{
  template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Expression const& tree) { return format(tree.root()); }
  template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Pattern const& tree) { return format(tree.root()); }
  template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Command const& tree) { return format(tree.root()); }
}
namespace expression_parser::locator::archive_part::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Expression const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Pattern const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Command const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct ExpressionFormatter { Expression const& tree; Formatter formatter; };
	template<class Formatter> struct PatternFormatter { Pattern const& tree; Formatter formatter; };
	template<class Formatter> struct CommandFormatter { Command const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression_parser::locator::archive_part{
	template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format_detail::ExpressionFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Expression const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format_detail::PatternFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Pattern const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format_detail::CommandFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Command const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
namespace expression_parser::locator::archive_root{
  template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Expression const& tree) { return format(tree.root()); }
  template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Pattern const& tree) { return format(tree.root()); }
  template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Command const& tree) { return format(tree.root()); }
}
namespace expression_parser::resolved::archive_part::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Expression const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Pattern const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> void format_indented(std::ostream& o, Command const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct ExpressionFormatter { Expression const& tree; Formatter formatter; };
	template<class Formatter> struct PatternFormatter { Pattern const& tree; Formatter formatter; };
	template<class Formatter> struct CommandFormatter { Command const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
  template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, CommandFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression_parser::resolved::archive_part{
	template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format_detail::ExpressionFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Expression const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format_detail::PatternFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Pattern const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
	template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format_detail::CommandFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Command const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
namespace expression_parser::resolved::archive_root{
  template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Expression const& tree) { return format(tree.root()); }
  template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Pattern const& tree) { return format(tree.root()); }
  template<class Formatter> auto format(Command const& tree, Formatter&& formatter) { return format(tree.root(), std::forward<Formatter>(formatter)); }
  inline auto format(Command const& tree) { return format(tree.root()); }
}
namespace expression_parser::located_output{
  struct Apply;
  struct Lambda;
  struct Identifier;
  struct Hole;
  struct Arrow;
  struct Block;
  struct Literal;
  struct PatternApply;
  struct PatternIdentifier;
  struct PatternHole;
  struct Declare;
  struct Rule;
  struct Axiom;
  struct Let;
  struct Expression {
    expression_parser::output::Expression output;
    expression_parser::locator::Expression locator;
    Expression(Apply);
    Expression(Lambda);
    Expression(Identifier);
    Expression(Hole);
    Expression(Arrow);
    Expression(Block);
    Expression(Literal);
  };
  struct Pattern {
    expression_parser::output::Pattern output;
    expression_parser::locator::Pattern locator;
    Pattern(PatternApply);
    Pattern(PatternIdentifier);
    Pattern(PatternHole);
  };
  struct Command {
    expression_parser::output::Command output;
    expression_parser::locator::Command locator;
    Command(Declare);
    Command(Rule);
    Command(Axiom);
    Command(Let);
  };
  struct Apply {
    Expression lhs;
    Expression rhs;
    std::string_view position;
  };
  struct Lambda {
    Expression body;
    std::optional<Expression> type;
    std::optional<std::string_view> arg_name;
    std::string_view position;
  };
  struct Identifier {
    std::string_view id;
    std::string_view position;
  };
  struct Hole {
    std::string_view position;
  };
  struct Arrow {
    Expression domain;
    Expression codomain;
    std::optional<std::string_view> arg_name;
    std::string_view position;
  };
  struct Block {
    std::vector<Command> statements;
    Expression value;
    std::string_view position;
  };
  struct Literal {
    literal::Any value;
    std::string_view position;
  };
  struct PatternApply {
    Pattern lhs;
    Pattern rhs;
    std::string_view position;
  };
  struct PatternIdentifier {
    std::string_view id;
    std::string_view position;
  };
  struct PatternHole {
    std::string_view position;
  };
  struct Declare {
    Expression type;
    std::string_view name;
    std::string_view position;
  };
  struct Rule {
    Pattern pattern;
    Expression replacement;
    std::string_view position;
  };
  struct Axiom {
    Expression type;
    std::string_view name;
    std::string_view position;
  };
  struct Let {
    Expression value;
    std::optional<Expression> type;
    std::string_view name;
    std::string_view position;
  };
}
#include "parser_tree_impl.inl"
#endif