#ifndef FILE_SOURCE_EXPRESSION_EXPRESSION_TREE_IMPL_HPP
#define FILE_SOURCE_EXPRESSION_EXPRESSION_TREE_IMPL_HPP
#include "data.hpp"
/*
This file is automatically generated! Edits made to it will be overwritten.
The contents of this file are generated from:
  Specification: Source/Expression/expression_tree.py
  Generator: /home/milo/Documents/Programming/TypeTheory4/Tools/source_generator.py
*/
#include "../Utility/indirect.hpp"
#include "../Utility/overloaded.hpp"
#include <variant>
#include <type_traits>
#include <vector>
#include <optional>
#include <cstdint>
#include <iostream>
#include <string>
#include <span>
#include <memory>
namespace expression::tree{
	struct Apply;
	struct Arg;
	struct External;
	struct Data;
	template<class Visitor> concept ExpressionVisitor = requires(Visitor visitor, Apply& apply, Arg& arg, External& external, Data& data) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(arg);
		std::forward<Visitor>(visitor)(external);
		std::forward<Visitor>(visitor)(data);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Arg&>, std::invoke_result_t<Visitor&&, External&>, std::invoke_result_t<Visitor&&, Data&> >;
	};
	template<class Visitor> concept ExpressionConstVisitor = requires(Visitor visitor, Apply const& apply, Arg const& arg, External const& external, Data const& data) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(arg);
		std::forward<Visitor>(visitor)(external);
		std::forward<Visitor>(visitor)(data);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Arg const&>, std::invoke_result_t<Visitor&&, External const&>, std::invoke_result_t<Visitor&&, Data const&> >;
	};
	template<class Visitor> concept ExpressionMoveVisitor = requires(Visitor visitor, Apply&& apply, Arg&& arg, External&& external, Data&& data) {
		std::forward<Visitor>(visitor)(std::move(apply));
		std::forward<Visitor>(visitor)(std::move(arg));
		std::forward<Visitor>(visitor)(std::move(external));
		std::forward<Visitor>(visitor)(std::move(data));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Arg&&>, std::invoke_result_t<Visitor&&, External&&>, std::invoke_result_t<Visitor&&, Data&&> >;
	};
	class Expression {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Expression(Apply arg);
		Expression(Arg arg);
		Expression(External arg);
		Expression(Data arg);
		Expression(Expression const&);
		Expression(Expression&&);
		Expression& operator=(Expression const&);
		Expression& operator=(Expression&&);
		~Expression();
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		bool holds_apply() const;
		Arg& get_arg() &;
		Arg const& get_arg() const&;
		Arg&& get_arg() &&;
		Arg* get_if_arg();
		Arg const* get_if_arg() const;
		bool holds_arg() const;
		External& get_external() &;
		External const& get_external() const&;
		External&& get_external() &&;
		External* get_if_external();
		External const* get_if_external() const;
		bool holds_external() const;
		Data& get_data() &;
		Data const& get_data() const&;
		Data&& get_data() &&;
		Data* get_if_data();
		Data const* get_if_data() const;
		bool holds_data() const;
		template<ExpressionVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Arg&>, std::invoke_result_t<Visitor&&, External&>, std::invoke_result_t<Visitor&&, Data&> >;
		template<ExpressionConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Arg const&>, std::invoke_result_t<Visitor&&, External const&>, std::invoke_result_t<Visitor&&, Data const&> >;
		template<ExpressionMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Arg&&>, std::invoke_result_t<Visitor&&, External&&>, std::invoke_result_t<Visitor&&, Data&&> >;
	};
	struct Apply {
		Expression lhs;
		Expression rhs;
	};
	struct Arg {
		std::uint64_t arg_index;
	};
	struct External {
		std::uint64_t external_index;
	};
	struct Data {
		data::Data data;
	};
	template<ExpressionVisitor Visitor> auto Expression::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Arg&>, std::invoke_result_t<Visitor&&, External&>, std::invoke_result_t<Visitor&&, Data&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Arg*)data);
			case 2: return std::forward<Visitor>(visitor)(*(External*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Data*)data);
			default: std::terminate();
		}
	}
	template<ExpressionConstVisitor Visitor> auto Expression::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Arg const&>, std::invoke_result_t<Visitor&&, External const&>, std::invoke_result_t<Visitor&&, Data const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Arg const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(External const*)data);
			case 3: return std::forward<Visitor>(visitor)(*(Data const*)data);
			default: std::terminate();
		}
	}
	template<ExpressionMoveVisitor Visitor> auto Expression::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Arg&&>, std::invoke_result_t<Visitor&&, External&&>, std::invoke_result_t<Visitor&&, Data&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Apply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Arg*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(External*)data));
			case 3: return std::forward<Visitor>(visitor)(std::move(*(Data*)data));
			default: std::terminate();
		}
	}
	bool operator==(Expression const&, Expression const&);
	bool operator==(Apply const&, Apply const&);
	bool operator==(Arg const&, Arg const&);
	bool operator==(External const&, External const&);
	bool operator==(Data const&, Data const&);
}
namespace expression::tree::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Expression const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct ExpressionFormatter { Expression const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, ExpressionFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression::tree{
	template<class Formatter> auto format(Expression const& tree, Formatter&& formatter) { return format_detail::ExpressionFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Expression const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
#include "expression_tree_impl.inl"
#endif