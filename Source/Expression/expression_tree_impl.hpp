/*
This file is automatically generated! Please do not make edits to it as they will be overwritten in the build process. Edits should instead be made to...
...the specification for this file:
...the script which generates these files:
*/

#include "../Utility/indirect.hpp"
#include "../Utility/overloaded.hpp"
#include <variant>
#include <type_traits>
#include <vector>
#include <optional>
#include <cstdint>
#include <iostream>
#include <string>

namespace expression::path {
  struct Path {
    std::vector<std::uint64_t> steps;
  };
  inline bool operator==(Path const& lhs, Path const& rhs) { return lhs.steps == rhs.steps; }
}



namespace expression::tree {

	struct Apply;
	struct External;
	struct Arg;

	class Tree {
		struct Impl;
		mdb::Indirect<Impl> data;
	public:
		Tree(Apply arg);
		Tree(External arg);
		Tree(Arg arg);

		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;

		External& get_external() &;
		External const& get_external() const&;
		External&& get_external() &&;
		External* get_if_external();
		External const* get_if_external() const;

		Arg& get_arg() &;
		Arg const& get_arg() const&;
		Arg&& get_arg() &&;
		Arg* get_if_arg();
		Arg const* get_if_arg() const;

		template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, External& external, Arg& arg) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<External&>(external));
	std::forward<Visitor&&>(visitor)(std::forward<Arg&>(arg));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, External&>, std::invoke_result_t<Visitor&&, Arg&> >;
})
		decltype(auto) visit(Visitor&&) &;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, External const& external, Arg const& arg) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<External const&>(external));
	std::forward<Visitor&&>(visitor)(std::forward<Arg const&>(arg));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, External const&>, std::invoke_result_t<Visitor&&, Arg const&> >;
})
		decltype(auto) visit(Visitor&&) const&;
		template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, External&& external, Arg&& arg) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<External&&>(external));
	std::forward<Visitor&&>(visitor)(std::forward<Arg&&>(arg));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, External&&>, std::invoke_result_t<Visitor&&, Arg&&> >;
})
		decltype(auto) visit(Visitor&&) &&;

	};
	struct Apply {
		Tree lhs;
		Tree rhs;
	};
	struct External {
		std::uint64_t index;
	};
	struct Arg {
		std::uint64_t index;
	};


	struct Tree::Impl {
		std::variant<Apply, External, Arg> data;
	};

	inline Tree::Tree(Apply arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(External arg):data(mdb::in_place, std::move(arg)) {}
	inline Tree::Tree(Arg arg):data(mdb::in_place, std::move(arg)) {}

	inline Apply& Tree::get_apply() & { return std::get<Apply>(data->data); }
	inline Apply const& Tree::get_apply() const& { return std::get<Apply>(data->data); }
	inline Apply&& Tree::get_apply() && { return std::move(std::get<Apply>(data->data)); }
	inline Apply* Tree::get_if_apply() { return std::get_if<Apply>(&data->data); }
	inline Apply const* Tree::get_if_apply() const { return std::get_if<Apply>(&data->data); }

	inline External& Tree::get_external() & { return std::get<External>(data->data); }
	inline External const& Tree::get_external() const& { return std::get<External>(data->data); }
	inline External&& Tree::get_external() && { return std::move(std::get<External>(data->data)); }
	inline External* Tree::get_if_external() { return std::get_if<External>(&data->data); }
	inline External const* Tree::get_if_external() const { return std::get_if<External>(&data->data); }

	inline Arg& Tree::get_arg() & { return std::get<Arg>(data->data); }
	inline Arg const& Tree::get_arg() const& { return std::get<Arg>(data->data); }
	inline Arg&& Tree::get_arg() && { return std::move(std::get<Arg>(data->data)); }
	inline Arg* Tree::get_if_arg() { return std::get_if<Arg>(&data->data); }
	inline Arg const* Tree::get_if_arg() const { return std::get_if<Arg>(&data->data); }


	template<class Visitor> requires (requires(Visitor&& visitor, Apply& apply, External& external, Arg& arg) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<External&>(external));
	std::forward<Visitor&&>(visitor)(std::forward<Arg&>(arg));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, External&>, std::invoke_result_t<Visitor&&, Arg&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) & {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply const& apply, External const& external, Arg const& arg) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply const&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<External const&>(external));
	std::forward<Visitor&&>(visitor)(std::forward<Arg const&>(arg));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, External const&>, std::invoke_result_t<Visitor&&, Arg const&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) const& {
		return std::visit(std::forward<Visitor>(visitor), data->data);
	}
	template<class Visitor> requires (requires(Visitor&& visitor, Apply&& apply, External&& external, Arg&& arg) {
	std::forward<Visitor&&>(visitor)(std::forward<Apply&&>(apply));
	std::forward<Visitor&&>(visitor)(std::forward<External&&>(external));
	std::forward<Visitor&&>(visitor)(std::forward<Arg&&>(arg));
	typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, External&&>, std::invoke_result_t<Visitor&&, Arg&&> >;
})
	decltype(auto) Tree::visit(Visitor&& visitor) && {
		return std::visit(std::forward<Visitor>(visitor), std::move(data->data));
	}


inline std::uint64_t path_segment_of(Tree Apply::* member) {
  if(member == &Apply::lhs) return 0;
  if(member == &Apply::rhs) return 1;
  std::terminate(); //unreachable
}
template<class... Ts>
inline void path_append(expression::path::Path& path, Ts&&... ts) {
  (path.steps.push_back(path_segment_of(ts)) , ...);
}
template<class... Ts>
inline expression::path::Path path_of(Ts&&... ts) {
  expression::path::Path ret;
  path_append(ret, std::forward<Ts>(ts)...);
  return ret;
}


  inline Tree& path_step(Tree& in, std::uint64_t step) {
    return in.visit([&]<class T>(T& part) -> Tree& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;

        case 1: return part.rhs;

        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, External>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Arg>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }


  inline Tree const& path_step(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T const& part) -> Tree const& {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return part.lhs;

        case 1: return part.rhs;

        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, External>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Arg>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }


    inline Tree& path_lookup(Tree& in, expression::path::Path const& path) {
      auto* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }


    inline Tree const& path_lookup(Tree const& in, expression::path::Path const& path) {
      auto const* ret = &in;
      for(auto step : path.steps) {
        ret = &path_step(*ret, step);
      }
      return *ret;
    }

  inline std::uint64_t children_count_of(Tree const& in) {
    return in.visit([&]<class T>(T const& part) -> std::uint64_t {
      if constexpr(std::is_same_v<T, Apply>) {
        return 2;
      }
      if constexpr(std::is_same_v<T, External>) {
        return 0;
      }
      if constexpr(std::is_same_v<T, Arg>) {
        return 0;
      }
    });
  }
  inline bool is_child_valid(Tree const& in, std::uint64_t step) {
    return in.visit([&]<class T>(T part) -> bool {
      if constexpr(std::is_same_v<T, Apply>) {
        switch(step) {
        case 0: return true;

        case 1: return true;

        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, External>) {
        switch(step) {
        default: std::terminate();
        }
      }
      if constexpr(std::is_same_v<T, Arg>) {
        switch(step) {
        default: std::terminate();
        }
      }
    });
  }

  namespace detail {
    struct IteratorOutput {
      expression::path::Path const& path;
      Tree& head;
    };
    class Iterator {
      expression::path::Path path;
      std::vector<Tree*> stack;
      friend bool operator==(Iterator const& lhs, Iterator const& rhs) {
        return lhs.stack == rhs.stack && lhs.path == rhs.path;
      }
    public:
      Iterator() = default;
      explicit Iterator(Tree& base):stack{&base}{}
      IteratorOutput operator*() const {
        return {
          .path = path,
          .head = *stack.back()
        };
      }
      Iterator& operator++() {
        path.steps.push_back(0); //start looking at the first child of the given node
        while(!stack.empty()) {
          auto& back = *stack.back();
          auto& path_back = path.steps.back();
          auto max_steps = children_count_of(back);
          for(;path_back < max_steps;++path_back) {
            if(is_child_valid(back, path_back)) {
              stack.push_back(&path_step(back, path_back));
              return *this;
            }
          }
          stack.pop_back(); //step outwards
          path.steps.pop_back();
          if(!path.steps.empty()) {
            ++path.steps.back(); //look at next child of given node
          }
        }
      }
    };
  }
  struct TreeRecursiveIterator {
    Tree& tree;
    detail::Iterator begin() const {
      return detail::Iterator{tree};
    }
    detail::Iterator end() const {
      return {};
    }
  };
  inline TreeRecursiveIterator recursive_range(Tree& tree) {
    return {.tree = tree};
  }


  namespace detail {
    struct IteratorOutputConst {
      expression::path::Path const& path;
      Tree const& head;
    };
    class IteratorConst {
      expression::path::Path path;
      std::vector<Tree const*> stack;
      friend bool operator==(IteratorConst const& lhs, IteratorConst const& rhs) {
        return lhs.stack == rhs.stack && lhs.path == rhs.path;
      }
    public:
      IteratorConst() = default;
      explicit IteratorConst(Tree const& base):stack{&base}{}
      IteratorOutputConst operator*() const {
        return {
          .path = path,
          .head = *stack.back()
        };
      }
      IteratorConst& operator++() {
        path.steps.push_back(0); //start looking at the first child of the given node
        while(!stack.empty()) {
          auto const& back = *stack.back();
          auto& path_back = path.steps.back();
          auto max_steps = children_count_of(back);
          for(;path_back < max_steps;++path_back) {
            if(is_child_valid(back, path_back)) {
              stack.push_back(&path_step(back, path_back));
              return *this;
            }
          }
          stack.pop_back(); //step outwards
          path.steps.pop_back();
          if(!path.steps.empty()) {
            ++path.steps.back(); //look at next child of given node
          }
        }
      }
    };
  }
  struct TreeRecursiveIteratorConst {
    Tree const& tree;
    detail::IteratorConst begin() const {
      return detail::IteratorConst{tree};
    }
    detail::IteratorConst end() const {
      return {};
    }
  };
  inline TreeRecursiveIteratorConst recursive_range(Tree const& tree) {
    return {.tree = tree};
  }

  namespace match_result {

    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
  	};
    template<class Lhs, class Rhs> Apply(Lhs&&, Rhs&&) -> Apply<Lhs, Rhs>;

    template<class Index>
  	struct External {
  		Index index;
  	};
    template<class Index> External(Index&&) -> External<Index>;

    template<class Index>
  	struct Arg {
  		Index index;
  	};
    template<class Index> Arg(Index&&) -> Arg<Index>;

  }
  namespace match {
    struct Any {
      template<class T>
      bool check(T const&) const { return true; }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    struct None {
      template<class T>
      bool check(std::optional<T> const& opt) const { return !opt.has_value(); }
      template<class T>
      auto match(T&& value) { return std::nullopt; }
    };
    template<class Inner>
    struct Some {
      Inner inner;
      template<class T>
      bool check(std::optional<T> const& opt) const { return opt.has_value() && inner.check(*opt); }
      template<class T>
      T match(std::optional<T>&& value) { return std::move(*value); }
      template<class T>
      T& match(std::optional<T>& value) { return *value; }
      template<class T>
      T const& match(std::optional<T> const& value) { return *value; }
    };
    template<class Matcher, class Test>
    struct Filter {
      Matcher matcher;
      Test test;
      template<class T>
      bool check(T const& value) const { return matcher(value) && test(value); }
      template<class T>
      decltype(auto) match(T&& value) const { return matcher(std::forward<T>(value)); }
    };
    template<class Matcher, class Test> Filter(Matcher, Test) -> Filter<Matcher, Test>;
    template<class Test>
    struct Predicate {
      Test test;
      template<class T>
      bool check(T const& value) const { return test(value); }
      template<class T>
      T match(T&& value) const { return std::forward<T>(value); }
    };
    template<class Test> Predicate(Test) -> Predicate<Test>;
    template<class Lhs, class Rhs>
  	struct Apply {
  		Lhs lhs;
  		Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }

      }
      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
  	struct External {
      bool check(Tree const& tree) const {
        return true;

      }
      auto match(Tree& tree) const {
        auto& component = tree.get_external();
        return match_result::External{
            .index = component.index
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_external();
        return match_result::External{
            .index = std::move(component.index)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_external();
        return match_result::External{
            .index = component.index
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  	struct Arg {
      bool check(Tree const& tree) const {
        return true;

      }
      auto match(Tree& tree) const {
        auto& component = tree.get_arg();
        return match_result::Arg{
            .index = component.index
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree&& tree) const {
        auto&& component = tree.get_arg();
        return match_result::Arg{
            .index = std::move(component.index)
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
      auto match(Tree const& tree) const {
        auto const& component = tree.get_arg();
        return match_result::Arg{
            .index = component.index
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
  }
  namespace full_match {
    template<class Lhs, class Rhs>
    struct Apply {
      Lhs lhs;
      Rhs rhs;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_apply()) {
          return lhs.check(component->lhs)
              && rhs.check(component->rhs);
        } else {
          return false;
        }

      }

      auto match(Tree& tree) const {
        auto& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }

      auto match(Tree&& tree) const {
        auto&& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(std::move(component.lhs)),
            .rhs = rhs.match(std::move(component.rhs))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }

      auto match(Tree const& tree) const {
        auto const& component = tree.get_apply();
        return match_result::Apply{
            .lhs = lhs.match(component.lhs),
            .rhs = rhs.match(component.rhs)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Lhs, class Rhs> Apply(Lhs, Rhs) -> Apply<Lhs, Rhs>;
    template<class Index>
    struct External {
      Index index;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_external()) {
          return index.check(component->index);
        } else {
          return false;
        }

      }

      auto match(Tree& tree) const {
        auto& component = tree.get_external();
        return match_result::External{
            .index = index.match(component.index)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }

      auto match(Tree&& tree) const {
        auto&& component = tree.get_external();
        return match_result::External{
            .index = index.match(std::move(component.index))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }

      auto match(Tree const& tree) const {
        auto const& component = tree.get_external();
        return match_result::External{
            .index = index.match(component.index)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Index> External(Index) -> External<Index>;
    template<class Index>
    struct Arg {
      Index index;
      bool check(Tree const& tree) const {
        if(auto const* component = tree.get_if_arg()) {
          return index.check(component->index);
        } else {
          return false;
        }

      }

      auto match(Tree& tree) const {
        auto& component = tree.get_arg();
        return match_result::Arg{
            .index = index.match(component.index)
        };
      }
      auto try_match(Tree& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }

      auto match(Tree&& tree) const {
        auto&& component = tree.get_arg();
        return match_result::Arg{
            .index = index.match(std::move(component.index))
        };
      }
      auto try_match(Tree&& tree) const {
        using MatchType = decltype(match(std::move(tree)));
        if(check(tree)) {
          return std::optional<MatchType>{match(std::move(tree))};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }

      auto match(Tree const& tree) const {
        auto const& component = tree.get_arg();
        return match_result::Arg{
            .index = index.match(component.index)
        };
      }
      auto try_match(Tree const& tree) const {
        using MatchType = decltype(match(tree));
        if(check(tree)) {
          return std::optional<MatchType>{match(tree)};
        } else {
          return std::optional<MatchType>{std::nullopt};
        }
      }
    };
    template<class Index> Arg(Index) -> Arg<Index>;
  }	bool operator==(Tree const& lhs, Tree const& rhs);

	inline bool operator==(Apply const& lhs, Apply const& rhs) {
		return lhs.lhs == rhs.lhs
		    && lhs.rhs == rhs.rhs;
	}
	inline bool operator==(External const& lhs, External const& rhs) {
		return lhs.index == rhs.index;
	}
	inline bool operator==(Arg const& lhs, Arg const& rhs) {
		return lhs.index == rhs.index;
	}


	inline bool operator==(Tree const& lhs, Tree const& rhs) {
		return lhs.visit(mdb::overloaded{
			[&](Apply const& component) {
				if(auto* other = rhs.get_if_apply()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](External const& component) {
				if(auto* other = rhs.get_if_external()) {
					return component == *other;
				} else {
					return false;
				}
			},
			[&](Arg const& component) {
				if(auto* other = rhs.get_if_arg()) {
					return component == *other;
				} else {
					return false;
				}
			}
		});
	}
	template<class Formatter>
	void format_indented(std::ostream& o, Tree const& value, std::size_t indent, Formatter&& format_inner = [](auto& o, auto const& v) { o << v; }) {
		auto make_indent = [&] { for(std::size_t i = 0; i < indent; ++i) o << "   "; };
		auto make_inner_indent = [&] { for(std::size_t i = 0; i <= indent; ++i) o << "   "; };
		value.visit(mdb::overloaded{
			[&](Apply const& component) {
				o << "Apply {\n";
				make_inner_indent(); o << ".lhs = "; format_indented(o, component.lhs, indent + 1, format_inner); o << "\n";
				make_inner_indent(); o << ".rhs = "; format_indented(o, component.rhs, indent + 1, format_inner); o << "\n";
				make_indent(); o << "}";
			},
			[&](External const& component) {
				o << "External {\n";
				make_inner_indent(); o << ".index = "; format_inner(o, component.index); o << "\n";
				make_indent(); o << "}";
			},
			[&](Arg const& component) {
				o << "Arg {\n";
				make_inner_indent(); o << ".index = "; format_inner(o, component.index); o << "\n";
				make_indent(); o << "}";
			}
		});
	}
	template<class Formatter>
	struct FormatTree {
		Tree const& tree;
		Formatter formatter;
	};
	template<class Formatter> FormatTree(Tree const&, Formatter&&) -> FormatTree<Formatter>;
	template<class Formatter>
	std::ostream& operator<<(std::ostream& o, FormatTree<Formatter> const& formatter) {
		format_indented(o, formatter.tree, 0, formatter.formatter);
		return o;
	}
}
