#ifndef FILE_SOURCE_EXPRESSION_PATTERN_TREE_IMPL_HPP
#define FILE_SOURCE_EXPRESSION_PATTERN_TREE_IMPL_HPP
/*
This file is automatically generated! Edits made to it will be overwritten.
The contents of this file are generated from:
  Specification: Source/Expression/pattern_tree.py
  Generator: /home/milo/Documents/Programming/TypeTheory4/Tools/source_generator.py
*/
#include "../Utility/indirect.hpp"
#include "../Utility/overloaded.hpp"
#include <variant>
#include <type_traits>
#include <vector>
#include <optional>
#include <cstdint>
#include <iostream>
#include <string>
#include <span>
#include <memory>
namespace expression::pattern{
	struct Apply;
	struct Fixed;
	struct Wildcard;
	template<class Visitor> concept PatternVisitor = requires(Visitor visitor, Apply& apply, Fixed& fixed, Wildcard& wildcard) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(fixed);
		std::forward<Visitor>(visitor)(wildcard);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Fixed&>, std::invoke_result_t<Visitor&&, Wildcard&> >;
	};
	template<class Visitor> concept PatternConstVisitor = requires(Visitor visitor, Apply const& apply, Fixed const& fixed, Wildcard const& wildcard) {
		std::forward<Visitor>(visitor)(apply);
		std::forward<Visitor>(visitor)(fixed);
		std::forward<Visitor>(visitor)(wildcard);
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Fixed const&>, std::invoke_result_t<Visitor&&, Wildcard const&> >;
	};
	template<class Visitor> concept PatternMoveVisitor = requires(Visitor visitor, Apply&& apply, Fixed&& fixed, Wildcard&& wildcard) {
		std::forward<Visitor>(visitor)(std::move(apply));
		std::forward<Visitor>(visitor)(std::move(fixed));
		std::forward<Visitor>(visitor)(std::move(wildcard));
		typename std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Fixed&&>, std::invoke_result_t<Visitor&&, Wildcard&&> >;
	};
	class Pattern {
		std::uint64_t index;
		void* data = nullptr;
	public:
		Pattern(Apply arg);
		Pattern(Fixed arg);
		Pattern(Wildcard arg);
		Pattern(Pattern const&);
		Pattern(Pattern&&);
		Pattern& operator=(Pattern const&);
		Pattern& operator=(Pattern&&);
		~Pattern();
		Apply& get_apply() &;
		Apply const& get_apply() const&;
		Apply&& get_apply() &&;
		Apply* get_if_apply();
		Apply const* get_if_apply() const;
		bool holds_apply() const;
		Fixed& get_fixed() &;
		Fixed const& get_fixed() const&;
		Fixed&& get_fixed() &&;
		Fixed* get_if_fixed();
		Fixed const* get_if_fixed() const;
		bool holds_fixed() const;
		Wildcard& get_wildcard() &;
		Wildcard const& get_wildcard() const&;
		Wildcard&& get_wildcard() &&;
		Wildcard* get_if_wildcard();
		Wildcard const* get_if_wildcard() const;
		bool holds_wildcard() const;
		template<PatternVisitor Visitor> auto visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Fixed&>, std::invoke_result_t<Visitor&&, Wildcard&> >;
		template<PatternConstVisitor Visitor> auto visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Fixed const&>, std::invoke_result_t<Visitor&&, Wildcard const&> >;
		template<PatternMoveVisitor Visitor> auto visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Fixed&&>, std::invoke_result_t<Visitor&&, Wildcard&&> >;
	};
	struct Apply {
		Pattern lhs;
		Pattern rhs;
	};
	struct Fixed {
		std::uint64_t external_index;
	};
	struct Wildcard {
	};
	template<PatternVisitor Visitor> auto Pattern::visit(Visitor&& visitor) & -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&>, std::invoke_result_t<Visitor&&, Fixed&>, std::invoke_result_t<Visitor&&, Wildcard&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Fixed*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Wildcard*)data);
			default: std::terminate();
		}
	}
	template<PatternConstVisitor Visitor> auto Pattern::visit(Visitor&& visitor) const& -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply const&>, std::invoke_result_t<Visitor&&, Fixed const&>, std::invoke_result_t<Visitor&&, Wildcard const&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(*(Apply const*)data);
			case 1: return std::forward<Visitor>(visitor)(*(Fixed const*)data);
			case 2: return std::forward<Visitor>(visitor)(*(Wildcard const*)data);
			default: std::terminate();
		}
	}
	template<PatternMoveVisitor Visitor> auto Pattern::visit(Visitor&& visitor) && -> std::common_type_t<std::invoke_result_t<Visitor&&, Apply&&>, std::invoke_result_t<Visitor&&, Fixed&&>, std::invoke_result_t<Visitor&&, Wildcard&&> > {
		if(!data) std::terminate();
		switch(index) {
			case 0: return std::forward<Visitor>(visitor)(std::move(*(Apply*)data));
			case 1: return std::forward<Visitor>(visitor)(std::move(*(Fixed*)data));
			case 2: return std::forward<Visitor>(visitor)(std::move(*(Wildcard*)data));
			default: std::terminate();
		}
	}
	bool operator==(Pattern const&, Pattern const&);
	bool operator==(Apply const&, Apply const&);
	bool operator==(Fixed const&, Fixed const&);
	bool operator==(Wildcard const&, Wildcard const&);
}
namespace expression::pattern::format_detail{
	template<class Formatter> void format_indented(std::ostream& o, Pattern const& value, std::size_t indent, Formatter&& format_inner);
	template<class Formatter> struct PatternFormatter { Pattern const& tree; Formatter formatter; };
  template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter> const& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
	template<class Formatter> std::ostream& operator<<(std::ostream& o, PatternFormatter<Formatter>&& formatter) { format_indented(o, formatter.tree, 0, formatter.formatter); return o; }
}
namespace expression::pattern{
	template<class Formatter> auto format(Pattern const& tree, Formatter&& formatter) { return format_detail::PatternFormatter<Formatter>{tree, std::forward<Formatter>(formatter)}; }
	inline auto format(Pattern const& tree) { return format(tree, [](std::ostream& o, auto const& v) { o << v; }); }
}
#include "pattern_tree_impl.inl"
#endif