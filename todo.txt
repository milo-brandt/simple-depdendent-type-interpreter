Optimization is a ~problem~ in this new setup - the unique-ing of arena.apply pretty consistently eats
~1/4 of the program's runtime, and clear_orphans takes a serious amount of time too (a lot of which is
just telling listeners that stuff was erased). Perhaps there's some way to avoid spending so many
resources on "one-off" expressions that aren't getting reused. The performance isn't terrible - even
compared to prior versions - but it's not great either.
* The best way might be to support both canonicalized expressions (the current system) *and* expressions
  stored merely as trees - storing a hash (based on the shape only) of all expressions and only canonicalizing
  expressions when we want to compare two trees with equal hashes. Then, these costs are only imposed in cases
  where there's an actual benefit (i.e. not merely for storing an expression). This is likely a serious undertaking
  as it would replace all comparisons.

A "closed expression" match statement could be worthwhile for passing things like proofs of correctness (to allow
compiling some piece of code). Would have to check to ensure that there are neither args nor indeterminate expressions
in the relevant argument.

Might also be worth adding a way for a replacement to take over the reducer, make "reduce" requests and handle the
stacks as it wants; this might be an effective way to avoid storing intermediate results (e.g. for implementing
C++ interpreters of native monads)


Adding explicit ways for replacement functions to interact with the stack might be worthwhile too.


----

Need better type utilities

Add test to ensure that axioms can't be defined by rules

Need to ensure that indeterminates are not defined from contexts with more assumptions.
Need to re-add support for U64s, Strings, Vectors.
* For Data: Should add a way to internally destructure pairs of things (for assumptions)
  - might accomplish this by adding a method to check whether two pieces of data are "shape-compatible"
    and, if so, to list all pairs that need to align for them to be equal.

Verify should probably allow deduction of holes *defined within verify itself*.

it crashes if there's an empty string (or empty string after import header)

could be worthwhile adding support for more general expression routines -
let C++ ask to manipulate reducer to avoid intermediate states needing to
be saved when we want to match something.

*************
High priority
*************
- Add automated testing
- Add "match" statement!

- Add an IO monad
- Add a system of traits
- Add a module system
- Add possibility for hidden arguments

************
Mid priority (as needed)
************
- Might consider allowing pattern matching through Data?
- Add destructuring Let statement
- Optimize expression contexts.
  - Probably faster to use shared_ptrs to avoid copying.
  - Can organize rules by their head.
  - Can add memoization (even possibly allow unique-ing of expressions)
  - Could refactor to a system of events and callbacks to avoid re-checking expressions when nothing's changed

************
Low priority
************
- Allow easy deduction of parts of rules - e.g. write unwrap _ (wrap _ x) = x.
- Revamp web interface
- Add other rules for equation solving
  - e.g. elimination of variables not held in common, expansion of tuple-like types,

- Archive generation should be more extensible - doesn't make sense to have internals of instruction.hpp in parser_tree.py
